window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "aalpy", "modulename": "aalpy", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.SULs", "modulename": "aalpy.SULs", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.SULs.AutomataSUL", "modulename": "aalpy.SULs.AutomataSUL", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.SULs.AutomataSUL.DfaSUL", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "DfaSUL", "type": "class", "doc": "<p>System under learning for DFAs.</p>\n", "bases": "aalpy.base.SUL.SUL"}, {"fullname": "aalpy.SULs.AutomataSUL.DfaSUL.__init__", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "DfaSUL.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, dfa: aalpy.automata.Dfa.Dfa)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.DfaSUL.pre", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "DfaSUL.pre", "type": "function", "doc": "<p>Resets the dfa to the initial state.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.DfaSUL.post", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "DfaSUL.post", "type": "function", "doc": "<p>Performs additional cleanup on the system in necessary. Called before pre method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.DfaSUL.step", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "DfaSUL.step", "type": "function", "doc": "<p>If the letter is empty/None check is preform to see if the empty string is accepted by the DFA.</p>\n\n<p>Args:</p>\n\n<pre><code>letter: single input or None representing the empty string\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>output of the dfa.step method (whether the next state is accepted or not)\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.MdpSUL", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "MdpSUL", "type": "class", "doc": "<p>System Under Learning (SUL) abstract class. Defines the interaction between the learning algorithm and the system\nunder learning. All systems under learning have to implement this class, as it is\npassed to the learning algorithm and the equivalence oracle.</p>\n", "bases": "aalpy.base.SUL.SUL"}, {"fullname": "aalpy.SULs.AutomataSUL.MdpSUL.__init__", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "MdpSUL.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, mdp: aalpy.automata.Mdp.Mdp)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.MdpSUL.query", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "MdpSUL.query", "type": "function", "doc": "<p>Performs a membership query on the SUL. Before the query, pre() method is called and after the query post()\nmethod is called. Each letter in the word (input in the input sequence) is executed using the step method.</p>\n\n<p>Args:</p>\n\n<pre><code>word: membership query (word consisting of letters/inputs)\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>list of outputs, where the i-th output corresponds to the output of the system after the i-th input\n</code></pre>\n", "signature": "(self, word: tuple) -> list", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.MdpSUL.pre", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "MdpSUL.pre", "type": "function", "doc": "<p>Resets the system. Called after post method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.MdpSUL.post", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "MdpSUL.post", "type": "function", "doc": "<p>Performs additional cleanup on the system in necessary. Called before pre method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.MdpSUL.step", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "MdpSUL.step", "type": "function", "doc": "<p>Executes an action on the system under learning and returns its result.</p>\n\n<p>Args:</p>\n\n<pre><code>letter: Single input that is executed on the SUL.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Output received after executing the input.\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.McSUL", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "McSUL", "type": "class", "doc": "<p>System Under Learning (SUL) abstract class. Defines the interaction between the learning algorithm and the system\nunder learning. All systems under learning have to implement this class, as it is\npassed to the learning algorithm and the equivalence oracle.</p>\n", "bases": "aalpy.base.SUL.SUL"}, {"fullname": "aalpy.SULs.AutomataSUL.McSUL.__init__", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "McSUL.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, mdp: aalpy.automata.MarkovChain.MarkovChain)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.McSUL.query", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "McSUL.query", "type": "function", "doc": "<p>Performs a membership query on the SUL. Before the query, pre() method is called and after the query post()\nmethod is called. Each letter in the word (input in the input sequence) is executed using the step method.</p>\n\n<p>Args:</p>\n\n<pre><code>word: membership query (word consisting of letters/inputs)\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>list of outputs, where the i-th output corresponds to the output of the system after the i-th input\n</code></pre>\n", "signature": "(self, word: tuple) -> list", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.McSUL.pre", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "McSUL.pre", "type": "function", "doc": "<p>Resets the system. Called after post method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.McSUL.post", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "McSUL.post", "type": "function", "doc": "<p>Performs additional cleanup on the system in necessary. Called before pre method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.McSUL.step", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "McSUL.step", "type": "function", "doc": "<p>Executes an action on the system under learning and returns its result.</p>\n\n<p>Args:</p>\n\n<pre><code>letter: Single input that is executed on the SUL.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Output received after executing the input.\n</code></pre>\n", "signature": "(self, letter=None)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.MealySUL", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "MealySUL", "type": "class", "doc": "<p>System under learning for Mealy machines.</p>\n", "bases": "aalpy.base.SUL.SUL"}, {"fullname": "aalpy.SULs.AutomataSUL.MealySUL.__init__", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "MealySUL.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, mm: aalpy.automata.MealyMachine.MealyMachine)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.MealySUL.pre", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "MealySUL.pre", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.MealySUL.post", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "MealySUL.post", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.MealySUL.step", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "MealySUL.step", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>letter: single non-Null input\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>output of the mealy.step method (output based on the input and the current state)\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.MooreSUL", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "MooreSUL", "type": "class", "doc": "<p>System under learning for Mealy machines.</p>\n", "bases": "aalpy.base.SUL.SUL"}, {"fullname": "aalpy.SULs.AutomataSUL.MooreSUL.__init__", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "MooreSUL.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, moore_machine: aalpy.automata.MooreMachine.MooreMachine)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.MooreSUL.pre", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "MooreSUL.pre", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.MooreSUL.post", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "MooreSUL.post", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.MooreSUL.step", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "MooreSUL.step", "type": "function", "doc": "<p>Executes an action on the system under learning and returns its result.</p>\n\n<p>Args:</p>\n\n<pre><code>letter: Single input that is executed on the SUL.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Output received after executing the input.\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.OnfsmSUL", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "OnfsmSUL", "type": "class", "doc": "<p>System Under Learning (SUL) abstract class. Defines the interaction between the learning algorithm and the system\nunder learning. All systems under learning have to implement this class, as it is\npassed to the learning algorithm and the equivalence oracle.</p>\n", "bases": "aalpy.base.SUL.SUL"}, {"fullname": "aalpy.SULs.AutomataSUL.OnfsmSUL.__init__", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "OnfsmSUL.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, mdp: aalpy.automata.Onfsm.Onfsm)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.OnfsmSUL.pre", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "OnfsmSUL.pre", "type": "function", "doc": "<p>Resets the system. Called after post method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.OnfsmSUL.post", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "OnfsmSUL.post", "type": "function", "doc": "<p>Performs additional cleanup on the system in necessary. Called before pre method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.OnfsmSUL.step", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "OnfsmSUL.step", "type": "function", "doc": "<p>Executes an action on the system under learning and returns its result.</p>\n\n<p>Args:</p>\n\n<pre><code>letter: Single input that is executed on the SUL.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Output received after executing the input.\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.StochasticMealySUL", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "StochasticMealySUL", "type": "class", "doc": "<p>System Under Learning (SUL) abstract class. Defines the interaction between the learning algorithm and the system\nunder learning. All systems under learning have to implement this class, as it is\npassed to the learning algorithm and the equivalence oracle.</p>\n", "bases": "aalpy.base.SUL.SUL"}, {"fullname": "aalpy.SULs.AutomataSUL.StochasticMealySUL.__init__", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "StochasticMealySUL.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    smm: aalpy.automata.StochasticMealyMachine.StochasticMealyMachine\n)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.StochasticMealySUL.pre", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "StochasticMealySUL.pre", "type": "function", "doc": "<p>Resets the system. Called after post method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.StochasticMealySUL.post", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "StochasticMealySUL.post", "type": "function", "doc": "<p>Performs additional cleanup on the system in necessary. Called before pre method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.AutomataSUL.StochasticMealySUL.step", "modulename": "aalpy.SULs.AutomataSUL", "qualname": "StochasticMealySUL.step", "type": "function", "doc": "<p>Executes an action on the system under learning and returns its result.</p>\n\n<p>Args:</p>\n\n<pre><code>letter: Single input that is executed on the SUL.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Output received after executing the input.\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.SULs.PyMethodSUL", "modulename": "aalpy.SULs.PyMethodSUL", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.SULs.PyMethodSUL.FunctionDecorator", "modulename": "aalpy.SULs.PyMethodSUL", "qualname": "FunctionDecorator", "type": "class", "doc": "<p>Decorator of methods found in the SUL class.</p>\n"}, {"fullname": "aalpy.SULs.PyMethodSUL.FunctionDecorator.__init__", "modulename": "aalpy.SULs.PyMethodSUL", "qualname": "FunctionDecorator.__init__", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>function: function of the class to be learned\n\nargs: arguments to be passed to the function. Either a single argument, or a list of arguments if\n    function has more than one parameter.\n</code></pre>\n", "signature": "(self, function, args=None)", "funcdef": "def"}, {"fullname": "aalpy.SULs.PyMethodSUL.PyClassSUL", "modulename": "aalpy.SULs.PyMethodSUL", "qualname": "PyClassSUL", "type": "class", "doc": "<p>System under learning for inferring python classes.</p>\n", "bases": "aalpy.base.SUL.SUL"}, {"fullname": "aalpy.SULs.PyMethodSUL.PyClassSUL.__init__", "modulename": "aalpy.SULs.PyMethodSUL", "qualname": "PyClassSUL.__init__", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>python_class: class to be learned\n</code></pre>\n", "signature": "(self, python_class)", "funcdef": "def"}, {"fullname": "aalpy.SULs.PyMethodSUL.PyClassSUL.pre", "modulename": "aalpy.SULs.PyMethodSUL", "qualname": "PyClassSUL.pre", "type": "function", "doc": "<p>Do the reset by initializing the class again or call reset method of the class</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.PyMethodSUL.PyClassSUL.post", "modulename": "aalpy.SULs.PyMethodSUL", "qualname": "PyClassSUL.post", "type": "function", "doc": "<p>Performs additional cleanup on the system in necessary. Called before pre method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.PyMethodSUL.PyClassSUL.step", "modulename": "aalpy.SULs.PyMethodSUL", "qualname": "PyClassSUL.step", "type": "function", "doc": "<p>Executes the function(with arguments) found in letter against the SUL</p>\n\n<p>Args:</p>\n\n<pre><code>letter: single input of type FunctionDecorator\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>output of the function\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.SULs.RegexSUL", "modulename": "aalpy.SULs.RegexSUL", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.SULs.RegexSUL.RegexSUL", "modulename": "aalpy.SULs.RegexSUL", "qualname": "RegexSUL", "type": "class", "doc": "<p>An example implementation of a system under learning that can be used to learn any regex expression.\nNote that the $ is added to the expression as in this SUL only exact matches are learned.</p>\n", "bases": "aalpy.base.SUL.SUL"}, {"fullname": "aalpy.SULs.RegexSUL.RegexSUL.__init__", "modulename": "aalpy.SULs.RegexSUL", "qualname": "RegexSUL.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, regex: str)", "funcdef": "def"}, {"fullname": "aalpy.SULs.RegexSUL.RegexSUL.pre", "modulename": "aalpy.SULs.RegexSUL", "qualname": "RegexSUL.pre", "type": "function", "doc": "<p>Resets the system. Called after post method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.RegexSUL.RegexSUL.post", "modulename": "aalpy.SULs.RegexSUL", "qualname": "RegexSUL.post", "type": "function", "doc": "<p>Performs additional cleanup on the system in necessary. Called before pre method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.RegexSUL.RegexSUL.step", "modulename": "aalpy.SULs.RegexSUL", "qualname": "RegexSUL.step", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>letter: single element of the input alphabet\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Whether the current string (previous string + letter) is accepted\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.SULs.TomitaSUL", "modulename": "aalpy.SULs.TomitaSUL", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.SULs.TomitaSUL.TomitaSUL", "modulename": "aalpy.SULs.TomitaSUL", "qualname": "TomitaSUL", "type": "class", "doc": "<p>Tomita grammars are often used as a benchmark for automata-related challenges. Simple SUL that implements all 7\nTomita grammars and enables their learning.</p>\n", "bases": "aalpy.base.SUL.SUL"}, {"fullname": "aalpy.SULs.TomitaSUL.TomitaSUL.__init__", "modulename": "aalpy.SULs.TomitaSUL", "qualname": "TomitaSUL.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, tomita_level_fun)", "funcdef": "def"}, {"fullname": "aalpy.SULs.TomitaSUL.TomitaSUL.pre", "modulename": "aalpy.SULs.TomitaSUL", "qualname": "TomitaSUL.pre", "type": "function", "doc": "<p>Resets the system. Called after post method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.TomitaSUL.TomitaSUL.post", "modulename": "aalpy.SULs.TomitaSUL", "qualname": "TomitaSUL.post", "type": "function", "doc": "<p>Performs additional cleanup on the system in necessary. Called before pre method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.SULs.TomitaSUL.TomitaSUL.step", "modulename": "aalpy.SULs.TomitaSUL", "qualname": "TomitaSUL.step", "type": "function", "doc": "<p>Executes an action on the system under learning and returns its result.</p>\n\n<p>Args:</p>\n\n<pre><code>letter: Single input that is executed on the SUL.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Output received after executing the input.\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.SULs.TomitaSUL.tomita_1", "modulename": "aalpy.SULs.TomitaSUL", "qualname": "tomita_1", "type": "function", "doc": "<p></p>\n", "signature": "(word)", "funcdef": "def"}, {"fullname": "aalpy.SULs.TomitaSUL.tomita_2", "modulename": "aalpy.SULs.TomitaSUL", "qualname": "tomita_2", "type": "function", "doc": "<p></p>\n", "signature": "(word)", "funcdef": "def"}, {"fullname": "aalpy.SULs.TomitaSUL.tomita_3", "modulename": "aalpy.SULs.TomitaSUL", "qualname": "tomita_3", "type": "function", "doc": "<p></p>\n", "signature": "(word)", "funcdef": "def"}, {"fullname": "aalpy.SULs.TomitaSUL.not_tomita_3", "modulename": "aalpy.SULs.TomitaSUL", "qualname": "not_tomita_3", "type": "function", "doc": "<p></p>\n", "signature": "(word)", "funcdef": "def"}, {"fullname": "aalpy.SULs.TomitaSUL.tomita_4", "modulename": "aalpy.SULs.TomitaSUL", "qualname": "tomita_4", "type": "function", "doc": "<p></p>\n", "signature": "(word)", "funcdef": "def"}, {"fullname": "aalpy.SULs.TomitaSUL.tomita_5", "modulename": "aalpy.SULs.TomitaSUL", "qualname": "tomita_5", "type": "function", "doc": "<p></p>\n", "signature": "(word)", "funcdef": "def"}, {"fullname": "aalpy.SULs.TomitaSUL.tomita_6", "modulename": "aalpy.SULs.TomitaSUL", "qualname": "tomita_6", "type": "function", "doc": "<p></p>\n", "signature": "(word)", "funcdef": "def"}, {"fullname": "aalpy.SULs.TomitaSUL.tomita_7", "modulename": "aalpy.SULs.TomitaSUL", "qualname": "tomita_7", "type": "function", "doc": "<p></p>\n", "signature": "(word)", "funcdef": "def"}, {"fullname": "aalpy.automata", "modulename": "aalpy.automata", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.automata.Dfa", "modulename": "aalpy.automata.Dfa", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.automata.Dfa.DfaState", "modulename": "aalpy.automata.Dfa", "qualname": "DfaState", "type": "class", "doc": "<p>Single state of a deterministic finite automaton.</p>\n", "bases": "aalpy.base.Automaton.AutomatonState"}, {"fullname": "aalpy.automata.Dfa.DfaState.__init__", "modulename": "aalpy.automata.Dfa", "qualname": "DfaState.__init__", "type": "function", "doc": "<p>Single state of an automaton. Each state consists of a state id, a dictionary of transitions, where the keys are\ninputs and the values are the corresponding target states, and a prefix that leads to the state from the initial\nstate.</p>\n\n<p>Args:</p>\n\n<pre><code>state_id(Any): used for graphical representation of the state. A good practice is to keep it unique.\n</code></pre>\n", "signature": "(self, state_id, is_accepting=False)", "funcdef": "def"}, {"fullname": "aalpy.automata.Dfa.Dfa", "modulename": "aalpy.automata.Dfa", "qualname": "Dfa", "type": "class", "doc": "<p>Deterministic finite automaton.</p>\n", "bases": "aalpy.base.Automaton.DeterministicAutomaton"}, {"fullname": "aalpy.automata.Dfa.Dfa.__init__", "modulename": "aalpy.automata.Dfa", "qualname": "Dfa.__init__", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>initial_state (AutomatonState): initial state of the automaton\nstates (list) : list containing all states of the automaton\n</code></pre>\n", "signature": "(self, initial_state: aalpy.automata.Dfa.DfaState, states)", "funcdef": "def"}, {"fullname": "aalpy.automata.Dfa.Dfa.step", "modulename": "aalpy.automata.Dfa", "qualname": "Dfa.step", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>letter: single input that is looked up in the transition table of the DfaState\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>True if the reached state is an accepting state, False otherwise\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.automata.Dfa.Dfa.compute_characterization_set", "modulename": "aalpy.automata.Dfa", "qualname": "Dfa.compute_characterization_set", "type": "function", "doc": "<p>Computation of a characterization set, that is, a set of sequences that can distinguish all states in the\nautomation. The implementation follows the approach for finding multiple preset diagnosing experiments described\nby Arthur Gill in \"Introduction to the Theory of Finite State Machines\".\nSome optional parameterized adaptations, e.g., for computing suffix-closed sets target the application in\nL*-based learning and conformance testing.\nThe function only works for minimal automata.\nArgs:\n    char_set_init: a list of sequence that will be included in the characterization set, e.g., the input\n                alphabet. A empty sequance is added to this list when using automata with state labels\n                (DFA and Moore)\n    online_suffix_closure: if true, ensures suffix closedness of the characterization set at every computation\n                        step\n    split_all_blocks: if false, the computation follows the original tree-based strategy, where newly computed\n                sequences are only checked on a subset of the states to be distinguished\n                if true, sequences are used to distinguish all states, yielding a potentially smaller set, which\n                is useful for conformance testing and learning</p>\n\n<p>Returns: a characterization set</p>\n", "signature": "(\n    self,\n    char_set_init=None,\n    online_suffix_closure=True,\n    split_all_blocks=True\n)", "funcdef": "def"}, {"fullname": "aalpy.automata.MarkovChain", "modulename": "aalpy.automata.MarkovChain", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.automata.MarkovChain.McState", "modulename": "aalpy.automata.MarkovChain", "qualname": "McState", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "aalpy.base.Automaton.AutomatonState"}, {"fullname": "aalpy.automata.MarkovChain.McState.__init__", "modulename": "aalpy.automata.MarkovChain", "qualname": "McState.__init__", "type": "function", "doc": "<p>Single state of an automaton. Each state consists of a state id, a dictionary of transitions, where the keys are\ninputs and the values are the corresponding target states, and a prefix that leads to the state from the initial\nstate.</p>\n\n<p>Args:</p>\n\n<pre><code>state_id(Any): used for graphical representation of the state. A good practice is to keep it unique.\n</code></pre>\n", "signature": "(self, state_id, output)", "funcdef": "def"}, {"fullname": "aalpy.automata.MarkovChain.MarkovChain", "modulename": "aalpy.automata.MarkovChain", "qualname": "MarkovChain", "type": "class", "doc": "<p>Markov Decision Process.</p>\n", "bases": "aalpy.base.Automaton.Automaton"}, {"fullname": "aalpy.automata.MarkovChain.MarkovChain.__init__", "modulename": "aalpy.automata.MarkovChain", "qualname": "MarkovChain.__init__", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>initial_state (AutomatonState): initial state of the automaton\nstates (list) : list containing all states of the automaton\n</code></pre>\n", "signature": "(self, initial_state, states: list)", "funcdef": "def"}, {"fullname": "aalpy.automata.MarkovChain.MarkovChain.reset_to_initial", "modulename": "aalpy.automata.MarkovChain", "qualname": "MarkovChain.reset_to_initial", "type": "function", "doc": "<p>Resets the current state of the automaton to the initial state</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.automata.MarkovChain.MarkovChain.step", "modulename": "aalpy.automata.MarkovChain", "qualname": "MarkovChain.step", "type": "function", "doc": "<p>Next step is determined based on transition probabilities of the current state.</p>\n\n<p>Args:</p>\n\n<pre><code>letter: input\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>output of the current state\n</code></pre>\n", "signature": "(self, letter=None)", "funcdef": "def"}, {"fullname": "aalpy.automata.MarkovChain.MarkovChain.step_to", "modulename": "aalpy.automata.MarkovChain", "qualname": "MarkovChain.step_to", "type": "function", "doc": "<p>Performs a step on the automaton based on the input <code>inp</code> and output <code>out</code>.</p>\n\n<p>Args:</p>\n\n<pre><code>input: input\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>output of the reached state, None otherwise\n</code></pre>\n", "signature": "(self, input)", "funcdef": "def"}, {"fullname": "aalpy.automata.Mdp", "modulename": "aalpy.automata.Mdp", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.automata.Mdp.MdpState", "modulename": "aalpy.automata.Mdp", "qualname": "MdpState", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "aalpy.base.Automaton.AutomatonState"}, {"fullname": "aalpy.automata.Mdp.MdpState.__init__", "modulename": "aalpy.automata.Mdp", "qualname": "MdpState.__init__", "type": "function", "doc": "<p>Single state of an automaton. Each state consists of a state id, a dictionary of transitions, where the keys are\ninputs and the values are the corresponding target states, and a prefix that leads to the state from the initial\nstate.</p>\n\n<p>Args:</p>\n\n<pre><code>state_id(Any): used for graphical representation of the state. A good practice is to keep it unique.\n</code></pre>\n", "signature": "(self, state_id, output=None)", "funcdef": "def"}, {"fullname": "aalpy.automata.Mdp.Mdp", "modulename": "aalpy.automata.Mdp", "qualname": "Mdp", "type": "class", "doc": "<p>Markov Decision Process.</p>\n", "bases": "aalpy.base.Automaton.Automaton"}, {"fullname": "aalpy.automata.Mdp.Mdp.__init__", "modulename": "aalpy.automata.Mdp", "qualname": "Mdp.__init__", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>initial_state (AutomatonState): initial state of the automaton\nstates (list) : list containing all states of the automaton\n</code></pre>\n", "signature": "(self, initial_state: aalpy.automata.Mdp.MdpState, states: list)", "funcdef": "def"}, {"fullname": "aalpy.automata.Mdp.Mdp.reset_to_initial", "modulename": "aalpy.automata.Mdp", "qualname": "Mdp.reset_to_initial", "type": "function", "doc": "<p>Resets the current state of the automaton to the initial state</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.automata.Mdp.Mdp.step", "modulename": "aalpy.automata.Mdp", "qualname": "Mdp.step", "type": "function", "doc": "<p>Next step is determined based on transition probabilities of the current state.</p>\n\n<p>Args:</p>\n\n<pre><code>letter: input\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>output of the current state\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.automata.Mdp.Mdp.step_to", "modulename": "aalpy.automata.Mdp", "qualname": "Mdp.step_to", "type": "function", "doc": "<p>Performs a step on the automaton based on the input <code>inp</code> and output <code>out</code>.</p>\n\n<p>Args:</p>\n\n<pre><code>inp: input\nout: output\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>output of the reached state, None otherwise\n</code></pre>\n", "signature": "(self, inp, out)", "funcdef": "def"}, {"fullname": "aalpy.automata.MealyMachine", "modulename": "aalpy.automata.MealyMachine", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.automata.MealyMachine.MealyState", "modulename": "aalpy.automata.MealyMachine", "qualname": "MealyState", "type": "class", "doc": "<p>Single state of a Mealy machine. Each state has an output_fun dictionary that maps inputs to outputs.</p>\n", "bases": "aalpy.base.Automaton.AutomatonState"}, {"fullname": "aalpy.automata.MealyMachine.MealyState.__init__", "modulename": "aalpy.automata.MealyMachine", "qualname": "MealyState.__init__", "type": "function", "doc": "<p>Single state of an automaton. Each state consists of a state id, a dictionary of transitions, where the keys are\ninputs and the values are the corresponding target states, and a prefix that leads to the state from the initial\nstate.</p>\n\n<p>Args:</p>\n\n<pre><code>state_id(Any): used for graphical representation of the state. A good practice is to keep it unique.\n</code></pre>\n", "signature": "(self, state_id)", "funcdef": "def"}, {"fullname": "aalpy.automata.MealyMachine.MealyMachine", "modulename": "aalpy.automata.MealyMachine", "qualname": "MealyMachine", "type": "class", "doc": "<p>Abstract class representing an automaton.</p>\n", "bases": "aalpy.base.Automaton.DeterministicAutomaton"}, {"fullname": "aalpy.automata.MealyMachine.MealyMachine.__init__", "modulename": "aalpy.automata.MealyMachine", "qualname": "MealyMachine.__init__", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>initial_state (AutomatonState): initial state of the automaton\nstates (list) : list containing all states of the automaton\n</code></pre>\n", "signature": "(self, initial_state: aalpy.automata.MealyMachine.MealyState, states)", "funcdef": "def"}, {"fullname": "aalpy.automata.MealyMachine.MealyMachine.step", "modulename": "aalpy.automata.MealyMachine", "qualname": "MealyMachine.step", "type": "function", "doc": "<p>In Mealy machines, outputs depend on the input and the current state.</p>\n\n<pre><code>Args:\n\n    letter: single input that is looked up in the transition and output functions\n\nReturns:\n\n    output corresponding to the input from the current state\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.automata.MooreMachine", "modulename": "aalpy.automata.MooreMachine", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.automata.MooreMachine.MooreState", "modulename": "aalpy.automata.MooreMachine", "qualname": "MooreState", "type": "class", "doc": "<p>Single state of a Moore machine. Each state has an output value.</p>\n", "bases": "aalpy.base.Automaton.AutomatonState"}, {"fullname": "aalpy.automata.MooreMachine.MooreState.__init__", "modulename": "aalpy.automata.MooreMachine", "qualname": "MooreState.__init__", "type": "function", "doc": "<p>Single state of an automaton. Each state consists of a state id, a dictionary of transitions, where the keys are\ninputs and the values are the corresponding target states, and a prefix that leads to the state from the initial\nstate.</p>\n\n<p>Args:</p>\n\n<pre><code>state_id(Any): used for graphical representation of the state. A good practice is to keep it unique.\n</code></pre>\n", "signature": "(self, state_id, output)", "funcdef": "def"}, {"fullname": "aalpy.automata.MooreMachine.MooreMachine", "modulename": "aalpy.automata.MooreMachine", "qualname": "MooreMachine", "type": "class", "doc": "<p>Abstract class representing an automaton.</p>\n", "bases": "aalpy.base.Automaton.DeterministicAutomaton"}, {"fullname": "aalpy.automata.MooreMachine.MooreMachine.__init__", "modulename": "aalpy.automata.MooreMachine", "qualname": "MooreMachine.__init__", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>initial_state (AutomatonState): initial state of the automaton\nstates (list) : list containing all states of the automaton\n</code></pre>\n", "signature": "(\n    self,\n    initial_state: aalpy.base.Automaton.AutomatonState,\n    states: list\n)", "funcdef": "def"}, {"fullname": "aalpy.automata.MooreMachine.MooreMachine.step", "modulename": "aalpy.automata.MooreMachine", "qualname": "MooreMachine.step", "type": "function", "doc": "<p>In Moore machines outputs depend on the current state.</p>\n\n<p>Args:</p>\n\n<pre><code>letter: single input that is looked up in the transition function leading to a new state\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>the output of the reached state\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.automata.MooreMachine.MooreMachine.compute_characterization_set", "modulename": "aalpy.automata.MooreMachine", "qualname": "MooreMachine.compute_characterization_set", "type": "function", "doc": "<p>Computation of a characterization set, that is, a set of sequences that can distinguish all states in the\nautomation. The implementation follows the approach for finding multiple preset diagnosing experiments described\nby Arthur Gill in \"Introduction to the Theory of Finite State Machines\".\nSome optional parameterized adaptations, e.g., for computing suffix-closed sets target the application in\nL*-based learning and conformance testing.\nThe function only works for minimal automata.\nArgs:\n    char_set_init: a list of sequence that will be included in the characterization set, e.g., the input\n                alphabet. A empty sequance is added to this list when using automata with state labels\n                (DFA and Moore)\n    online_suffix_closure: if true, ensures suffix closedness of the characterization set at every computation\n                        step\n    split_all_blocks: if false, the computation follows the original tree-based strategy, where newly computed\n                sequences are only checked on a subset of the states to be distinguished\n                if true, sequences are used to distinguish all states, yielding a potentially smaller set, which\n                is useful for conformance testing and learning</p>\n\n<p>Returns: a characterization set</p>\n", "signature": "(\n    self,\n    char_set_init=None,\n    online_suffix_closure=True,\n    split_all_blocks=True\n)", "funcdef": "def"}, {"fullname": "aalpy.automata.Onfsm", "modulename": "aalpy.automata.Onfsm", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.automata.Onfsm.OnfsmState", "modulename": "aalpy.automata.Onfsm", "qualname": "OnfsmState", "type": "class", "doc": "<p></p>\n", "bases": "aalpy.base.Automaton.AutomatonState"}, {"fullname": "aalpy.automata.Onfsm.OnfsmState.__init__", "modulename": "aalpy.automata.Onfsm", "qualname": "OnfsmState.__init__", "type": "function", "doc": "<p>Single state of an automaton. Each state consists of a state id, a dictionary of transitions, where the keys are\ninputs and the values are the corresponding target states, and a prefix that leads to the state from the initial\nstate.</p>\n\n<p>Args:</p>\n\n<pre><code>state_id(Any): used for graphical representation of the state. A good practice is to keep it unique.\n</code></pre>\n", "signature": "(self, state_id)", "funcdef": "def"}, {"fullname": "aalpy.automata.Onfsm.OnfsmState.add_transition", "modulename": "aalpy.automata.Onfsm", "qualname": "OnfsmState.add_transition", "type": "function", "doc": "<p>Args:\n  inp: \n  out: \n  new_state: </p>\n\n<p>Returns:</p>\n", "signature": "(self, inp, out, new_state)", "funcdef": "def"}, {"fullname": "aalpy.automata.Onfsm.OnfsmState.get_transition", "modulename": "aalpy.automata.Onfsm", "qualname": "OnfsmState.get_transition", "type": "function", "doc": "<p>Args:\n  input: \n  output:  (Default value = None)</p>\n\n<p>Returns:</p>\n", "signature": "(self, input, output=None)", "funcdef": "def"}, {"fullname": "aalpy.automata.Onfsm.Onfsm", "modulename": "aalpy.automata.Onfsm", "qualname": "Onfsm", "type": "class", "doc": "<p>Observable non-deterministic finite state automaton.</p>\n", "bases": "aalpy.base.Automaton.Automaton"}, {"fullname": "aalpy.automata.Onfsm.Onfsm.__init__", "modulename": "aalpy.automata.Onfsm", "qualname": "Onfsm.__init__", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>initial_state (AutomatonState): initial state of the automaton\nstates (list) : list containing all states of the automaton\n</code></pre>\n", "signature": "(self, initial_state: aalpy.automata.Onfsm.OnfsmState, states: list)", "funcdef": "def"}, {"fullname": "aalpy.automata.Onfsm.Onfsm.step", "modulename": "aalpy.automata.Onfsm", "qualname": "Onfsm.step", "type": "function", "doc": "<p>Next step is determined based on a uniform distribution over all transitions with the input 'letter'.</p>\n\n<p>Args:</p>\n\n<pre><code>letter: input\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>output of the probabilistically chosen transition\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.automata.Onfsm.Onfsm.outputs_on_input", "modulename": "aalpy.automata.Onfsm", "qualname": "Onfsm.outputs_on_input", "type": "function", "doc": "<p>All possible observable outputs after executing the current input 'letter'.</p>\n\n<p>Args:</p>\n\n<pre><code>letter: input\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>list of observable outputs\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.automata.Onfsm.Onfsm.step_to", "modulename": "aalpy.automata.Onfsm", "qualname": "Onfsm.step_to", "type": "function", "doc": "<p>Performs a step on the automaton based on the input <code>inp</code> and output <code>out</code>.</p>\n\n<p>Args:</p>\n\n<pre><code>inp: input\nout: output\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>output of the reached state, None otherwise\n</code></pre>\n", "signature": "(self, inp, out)", "funcdef": "def"}, {"fullname": "aalpy.automata.StochasticMealyMachine", "modulename": "aalpy.automata.StochasticMealyMachine", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.automata.StochasticMealyMachine.StochasticMealyState", "modulename": "aalpy.automata.StochasticMealyMachine", "qualname": "StochasticMealyState", "type": "class", "doc": "<p></p>\n", "bases": "aalpy.base.Automaton.AutomatonState"}, {"fullname": "aalpy.automata.StochasticMealyMachine.StochasticMealyState.__init__", "modulename": "aalpy.automata.StochasticMealyMachine", "qualname": "StochasticMealyState.__init__", "type": "function", "doc": "<p>Single state of an automaton. Each state consists of a state id, a dictionary of transitions, where the keys are\ninputs and the values are the corresponding target states, and a prefix that leads to the state from the initial\nstate.</p>\n\n<p>Args:</p>\n\n<pre><code>state_id(Any): used for graphical representation of the state. A good practice is to keep it unique.\n</code></pre>\n", "signature": "(self, state_id)", "funcdef": "def"}, {"fullname": "aalpy.automata.StochasticMealyMachine.StochasticMealyMachine", "modulename": "aalpy.automata.StochasticMealyMachine", "qualname": "StochasticMealyMachine", "type": "class", "doc": "<p>Abstract class representing an automaton.</p>\n", "bases": "aalpy.base.Automaton.Automaton"}, {"fullname": "aalpy.automata.StochasticMealyMachine.StochasticMealyMachine.__init__", "modulename": "aalpy.automata.StochasticMealyMachine", "qualname": "StochasticMealyMachine.__init__", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>initial_state (AutomatonState): initial state of the automaton\nstates (list) : list containing all states of the automaton\n</code></pre>\n", "signature": "(\n    self,\n    initial_state: aalpy.automata.StochasticMealyMachine.StochasticMealyState,\n    states: list\n)", "funcdef": "def"}, {"fullname": "aalpy.automata.StochasticMealyMachine.StochasticMealyMachine.reset_to_initial", "modulename": "aalpy.automata.StochasticMealyMachine", "qualname": "StochasticMealyMachine.reset_to_initial", "type": "function", "doc": "<p>Resets the current state of the automaton to the initial state</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.automata.StochasticMealyMachine.StochasticMealyMachine.step", "modulename": "aalpy.automata.StochasticMealyMachine", "qualname": "StochasticMealyMachine.step", "type": "function", "doc": "<p>Next step is determined based on transition probabilities of the current state.</p>\n\n<p>Args:</p>\n\n<p>letter: input</p>\n\n<p>Returns:</p>\n\n<p>output of the current state</p>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.automata.StochasticMealyMachine.StochasticMealyMachine.step_to", "modulename": "aalpy.automata.StochasticMealyMachine", "qualname": "StochasticMealyMachine.step_to", "type": "function", "doc": "<p>Performs a step on the automaton based on the input <code>inp</code> and output <code>out</code>.</p>\n\n<p>Args:</p>\n\n<pre><code>inp: input\nout: output\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>output of the reached state, None otherwise\n</code></pre>\n", "signature": "(self, inp, out)", "funcdef": "def"}, {"fullname": "aalpy.automata.StochasticMealyMachine.smm_to_mdp_conversion", "modulename": "aalpy.automata.StochasticMealyMachine", "qualname": "smm_to_mdp_conversion", "type": "function", "doc": "<p>Convert SMM to MDP.</p>\n\n<p>Args:\n  smm: StochasticMealyMachine: SMM to convert</p>\n\n<p>Returns:</p>\n\n<pre><code>equivalent MDP\n</code></pre>\n", "signature": "(smm: aalpy.automata.StochasticMealyMachine.StochasticMealyMachine)", "funcdef": "def"}, {"fullname": "aalpy.base", "modulename": "aalpy.base", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.base.Automaton", "modulename": "aalpy.base.Automaton", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.base.Automaton.AutomatonState", "modulename": "aalpy.base.Automaton", "qualname": "AutomatonState", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "abc.ABC"}, {"fullname": "aalpy.base.Automaton.AutomatonState.__init__", "modulename": "aalpy.base.Automaton", "qualname": "AutomatonState.__init__", "type": "function", "doc": "<p>Single state of an automaton. Each state consists of a state id, a dictionary of transitions, where the keys are\ninputs and the values are the corresponding target states, and a prefix that leads to the state from the initial\nstate.</p>\n\n<p>Args:</p>\n\n<pre><code>state_id(Any): used for graphical representation of the state. A good practice is to keep it unique.\n</code></pre>\n", "signature": "(self, state_id)", "funcdef": "def"}, {"fullname": "aalpy.base.Automaton.AutomatonState.get_diff_state_transitions", "modulename": "aalpy.base.Automaton", "qualname": "AutomatonState.get_diff_state_transitions", "type": "function", "doc": "<p>Returns a list of transitions that lead to new states, not same-state transitions.</p>\n", "signature": "(self) -> list", "funcdef": "def"}, {"fullname": "aalpy.base.Automaton.AutomatonState.get_same_state_transitions", "modulename": "aalpy.base.Automaton", "qualname": "AutomatonState.get_same_state_transitions", "type": "function", "doc": "<p>Get all transitions that lead to the same state (self loops).</p>\n", "signature": "(self) -> list", "funcdef": "def"}, {"fullname": "aalpy.base.Automaton.Automaton", "modulename": "aalpy.base.Automaton", "qualname": "Automaton", "type": "class", "doc": "<p>Abstract class representing an automaton.</p>\n", "bases": "abc.ABC"}, {"fullname": "aalpy.base.Automaton.Automaton.__init__", "modulename": "aalpy.base.Automaton", "qualname": "Automaton.__init__", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>initial_state (AutomatonState): initial state of the automaton\nstates (list) : list containing all states of the automaton\n</code></pre>\n", "signature": "(self, initial_state, states: list)", "funcdef": "def"}, {"fullname": "aalpy.base.Automaton.Automaton.reset_to_initial", "modulename": "aalpy.base.Automaton", "qualname": "Automaton.reset_to_initial", "type": "function", "doc": "<p>Resets the current state of the automaton to the initial state</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.base.Automaton.Automaton.step", "modulename": "aalpy.base.Automaton", "qualname": "Automaton.step", "type": "function", "doc": "<p>Performs a single step on the automaton changing its current state.</p>\n\n<p>Args:</p>\n\n<pre><code>letter: element of the input alphabet to be executed on the system under learning\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Output produced when executing the input letter from the current state\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.base.Automaton.Automaton.is_input_complete", "modulename": "aalpy.base.Automaton", "qualname": "Automaton.is_input_complete", "type": "function", "doc": "<p>Check whether all states have defined transition for all inputs\n:return: true if automaton is input complete</p>\n\n<p>Returns:</p>\n\n<pre><code>True if input complete, False otherwise\n</code></pre>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "aalpy.base.Automaton.Automaton.get_input_alphabet", "modulename": "aalpy.base.Automaton", "qualname": "Automaton.get_input_alphabet", "type": "function", "doc": "<p>Returns the input alphabet</p>\n", "signature": "(self) -> list", "funcdef": "def"}, {"fullname": "aalpy.base.Automaton.Automaton.get_state_by_id", "modulename": "aalpy.base.Automaton", "qualname": "Automaton.get_state_by_id", "type": "function", "doc": "<p></p>\n", "signature": "(self, state_id) -> aalpy.base.Automaton.AutomatonState", "funcdef": "def"}, {"fullname": "aalpy.base.Automaton.Automaton.execute_sequence", "modulename": "aalpy.base.Automaton", "qualname": "Automaton.execute_sequence", "type": "function", "doc": "<p></p>\n", "signature": "(self, origin_state, seq)", "funcdef": "def"}, {"fullname": "aalpy.base.Automaton.DeterministicAutomaton", "modulename": "aalpy.base.Automaton", "qualname": "DeterministicAutomaton", "type": "class", "doc": "<p>Abstract class representing an automaton.</p>\n", "bases": "Automaton"}, {"fullname": "aalpy.base.Automaton.DeterministicAutomaton.step", "modulename": "aalpy.base.Automaton", "qualname": "DeterministicAutomaton.step", "type": "function", "doc": "<p>Performs a single step on the automaton changing its current state.</p>\n\n<p>Args:</p>\n\n<pre><code>letter: element of the input alphabet to be executed on the system under learning\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Output produced when executing the input letter from the current state\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.base.Automaton.DeterministicAutomaton.get_shortest_path", "modulename": "aalpy.base.Automaton", "qualname": "DeterministicAutomaton.get_shortest_path", "type": "function", "doc": "<p>Breath First Search over the automaton</p>\n\n<p>Args:</p>\n\n<pre><code>origin_state (AutomatonState): state from which the BFS will start\ntarget_state (AutomatonState): state that will be reached with the return value\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>sequence of inputs that lead from origin_state to target state\n</code></pre>\n", "signature": "(\n    self,\n    origin_state: aalpy.base.Automaton.AutomatonState,\n    target_state: aalpy.base.Automaton.AutomatonState\n) -> tuple", "funcdef": "def"}, {"fullname": "aalpy.base.Automaton.DeterministicAutomaton.is_strongly_connected", "modulename": "aalpy.base.Automaton", "qualname": "DeterministicAutomaton.is_strongly_connected", "type": "function", "doc": "<p>Check whether the automaton is strongly connected,\nmeaning that every state can be reached from every other state.</p>\n\n<p>Returns:</p>\n\n<pre><code>True if strongly connected, False otherwise\n</code></pre>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "aalpy.base.Automaton.DeterministicAutomaton.output_step", "modulename": "aalpy.base.Automaton", "qualname": "DeterministicAutomaton.output_step", "type": "function", "doc": "<p>Given an input letter, compute the output response from a given state.\nArgs:\n    state: state from which the output response shall be computed\n    letter: an input letter from the alphabet</p>\n\n<p>Returns: the single-step output response</p>\n", "signature": "(self, state, letter)", "funcdef": "def"}, {"fullname": "aalpy.base.Automaton.DeterministicAutomaton.find_distinguishing_seq", "modulename": "aalpy.base.Automaton", "qualname": "DeterministicAutomaton.find_distinguishing_seq", "type": "function", "doc": "<p>A BFS to determine an input sequence that distinguishes two states in the automaton, i.e., a sequence such that\nthe output response from the given states is different. In a minimal automaton, this function always returns a\nsequence different from None\nArgs:\n    state1: first state\n    state2: second state to distinguish</p>\n\n<p>Returns: an input sequence distinguishing two states, or None if the states are equivalent</p>\n", "signature": "(self, state1, state2)", "funcdef": "def"}, {"fullname": "aalpy.base.Automaton.DeterministicAutomaton.compute_output_seq", "modulename": "aalpy.base.Automaton", "qualname": "DeterministicAutomaton.compute_output_seq", "type": "function", "doc": "<p>Given an input sequence, compute the output response from a given state.\nArgs:\n    state: state from which the output response shall be computed\n    sequence: an input sequence over the alphabet</p>\n\n<p>Returns: the output response</p>\n", "signature": "(self, state, sequence)", "funcdef": "def"}, {"fullname": "aalpy.base.Automaton.DeterministicAutomaton.compute_characterization_set", "modulename": "aalpy.base.Automaton", "qualname": "DeterministicAutomaton.compute_characterization_set", "type": "function", "doc": "<p>Computation of a characterization set, that is, a set of sequences that can distinguish all states in the\nautomation. The implementation follows the approach for finding multiple preset diagnosing experiments described\nby Arthur Gill in \"Introduction to the Theory of Finite State Machines\".\nSome optional parameterized adaptations, e.g., for computing suffix-closed sets target the application in\nL*-based learning and conformance testing.\nThe function only works for minimal automata.\nArgs:\n    char_set_init: a list of sequence that will be included in the characterization set, e.g., the input\n                alphabet. A empty sequance is added to this list when using automata with state labels\n                (DFA and Moore)\n    online_suffix_closure: if true, ensures suffix closedness of the characterization set at every computation\n                        step\n    split_all_blocks: if false, the computation follows the original tree-based strategy, where newly computed\n                sequences are only checked on a subset of the states to be distinguished\n                if true, sequences are used to distinguish all states, yielding a potentially smaller set, which\n                is useful for conformance testing and learning</p>\n\n<p>Returns: a characterization set</p>\n", "signature": "(\n    self,\n    char_set_init=None,\n    online_suffix_closure=True,\n    split_all_blocks=True\n)", "funcdef": "def"}, {"fullname": "aalpy.base.CacheTree", "modulename": "aalpy.base.CacheTree", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.base.CacheTree.Node", "modulename": "aalpy.base.CacheTree", "qualname": "Node", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aalpy.base.CacheTree.Node.__init__", "modulename": "aalpy.base.CacheTree", "qualname": "Node.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, value=None)", "funcdef": "def"}, {"fullname": "aalpy.base.CacheTree.CacheTree", "modulename": "aalpy.base.CacheTree", "qualname": "CacheTree", "type": "class", "doc": "<p>Tree in which all membership queries and corresponding outputs/values are stored. Membership queries update the tree\nand while updating, check if determinism is maintained.\nRoot node corresponds to the initial state, and from that point on, for every new input/output pair, a new child is\ncreated where the output is the value of the child, and the input is the transition leading from the parent to the\nchild.</p>\n"}, {"fullname": "aalpy.base.CacheTree.CacheTree.__init__", "modulename": "aalpy.base.CacheTree", "qualname": "CacheTree.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.base.CacheTree.CacheTree.reset", "modulename": "aalpy.base.CacheTree", "qualname": "CacheTree.reset", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.base.CacheTree.CacheTree.step_in_cache", "modulename": "aalpy.base.CacheTree", "qualname": "CacheTree.step_in_cache", "type": "function", "doc": "<p>Preform a step in the cache. If output exist for the current state, and is not the same as <code>out</code>, throw\nthe non-determinism violation error and abort learning.\nArgs:</p>\n\n<pre><code>inp: input\nout: output\n</code></pre>\n", "signature": "(self, inp, out)", "funcdef": "def"}, {"fullname": "aalpy.base.CacheTree.CacheTree.in_cache", "modulename": "aalpy.base.CacheTree", "qualname": "CacheTree.in_cache", "type": "function", "doc": "<p>Check if the result of the membership query for input_seq is cached is in the tree. If it is, return the\ncorresponding output sequence.</p>\n\n<p>Args:</p>\n\n<pre><code>input_seq: corresponds to the membership query\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>outputs associated with inputs if it is in the query, None otherwise\n</code></pre>\n", "signature": "(self, input_seq: tuple)", "funcdef": "def"}, {"fullname": "aalpy.base.Oracle", "modulename": "aalpy.base.Oracle", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.base.Oracle.Oracle", "modulename": "aalpy.base.Oracle", "qualname": "Oracle", "type": "class", "doc": "<p>Abstract class implemented by all equivalence oracles.</p>\n", "bases": "abc.ABC"}, {"fullname": "aalpy.base.Oracle.Oracle.__init__", "modulename": "aalpy.base.Oracle", "qualname": "Oracle.__init__", "type": "function", "doc": "<p>Default constructor for all equivalence oracles.</p>\n\n<p>Args:</p>\n\n<pre><code>alphabet: input alphabet\nsul: system under learning\n</code></pre>\n", "signature": "(\n    self,\n    alphabet: list,\n    sul: <module 'aalpy.base.SUL' from 'C:\\\\Users\\\\MSI\\\\Documents\\\\PyCharmProject\\\\AALpy\\\\.\\\\aalpy\\\\base\\\\SUL.py'>\n)", "funcdef": "def"}, {"fullname": "aalpy.base.Oracle.Oracle.find_cex", "modulename": "aalpy.base.Oracle", "qualname": "Oracle.find_cex", "type": "function", "doc": "<p>Return a counterexample (inputs) that displays different behavior on system under learning and\ncurrent hypothesis.</p>\n\n<p>Args:</p>\n\n<p>hypothesis: current hypothesis</p>\n\n<p>Returns:</p>\n\n<pre><code>tuple or list containing counterexample inputs, None if no counterexample is found\n</code></pre>\n", "signature": "(self, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.base.Oracle.Oracle.reset_hyp_and_sul", "modulename": "aalpy.base.Oracle", "qualname": "Oracle.reset_hyp_and_sul", "type": "function", "doc": "<p>Reset SUL and hypothesis to initial state.</p>\n\n<p>Args:</p>\n\n<pre><code>hypothesis: current hypothesis\n</code></pre>\n", "signature": "(self, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.base.SUL", "modulename": "aalpy.base.SUL", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.base.SUL.SUL", "modulename": "aalpy.base.SUL", "qualname": "SUL", "type": "class", "doc": "<p>System Under Learning (SUL) abstract class. Defines the interaction between the learning algorithm and the system\nunder learning. All systems under learning have to implement this class, as it is\npassed to the learning algorithm and the equivalence oracle.</p>\n", "bases": "abc.ABC"}, {"fullname": "aalpy.base.SUL.SUL.query", "modulename": "aalpy.base.SUL", "qualname": "SUL.query", "type": "function", "doc": "<p>Performs a membership query on the SUL. Before the query, pre() method is called and after the query post()\nmethod is called. Each letter in the word (input in the input sequence) is executed using the step method.</p>\n\n<p>Args:</p>\n\n<pre><code>word: membership query (word consisting of letters/inputs)\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>list of outputs, where the i-th output corresponds to the output of the system after the i-th input\n</code></pre>\n", "signature": "(self, word: tuple) -> list", "funcdef": "def"}, {"fullname": "aalpy.base.SUL.SUL.pre", "modulename": "aalpy.base.SUL", "qualname": "SUL.pre", "type": "function", "doc": "<p>Resets the system. Called after post method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.base.SUL.SUL.post", "modulename": "aalpy.base.SUL", "qualname": "SUL.post", "type": "function", "doc": "<p>Performs additional cleanup on the system in necessary. Called before pre method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.base.SUL.SUL.step", "modulename": "aalpy.base.SUL", "qualname": "SUL.step", "type": "function", "doc": "<p>Executes an action on the system under learning and returns its result.</p>\n\n<p>Args:</p>\n\n<pre><code>letter: Single input that is executed on the SUL.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Output received after executing the input.\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.base.SUL.CacheSUL", "modulename": "aalpy.base.SUL", "qualname": "CacheSUL", "type": "class", "doc": "<p>System under learning that keeps a multiset of all queries in memory.\nThis multiset/cache is encoded as a tree.</p>\n", "bases": "SUL"}, {"fullname": "aalpy.base.SUL.CacheSUL.__init__", "modulename": "aalpy.base.SUL", "qualname": "CacheSUL.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, sul: aalpy.base.SUL.SUL)", "funcdef": "def"}, {"fullname": "aalpy.base.SUL.CacheSUL.query", "modulename": "aalpy.base.SUL", "qualname": "CacheSUL.query", "type": "function", "doc": "<p>Performs a membership query on the SUL if and only if <code>word</code> is not a prefix of any trace in the cache.\nBefore the query, pre() method is called and after the query post()\nmethod is called. Each letter in the word (input in the input sequence) is executed using the step method.</p>\n\n<p>Args:</p>\n\n<pre><code>word: membership query (word consisting of letters/inputs)\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>list of outputs, where the i-th output corresponds to the output of the system after the i-th input\n</code></pre>\n", "signature": "(self, word)", "funcdef": "def"}, {"fullname": "aalpy.base.SUL.CacheSUL.pre", "modulename": "aalpy.base.SUL", "qualname": "CacheSUL.pre", "type": "function", "doc": "<p>Reset the system under learning and current node in the cache tree.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.base.SUL.CacheSUL.post", "modulename": "aalpy.base.SUL", "qualname": "CacheSUL.post", "type": "function", "doc": "<p>Performs additional cleanup on the system in necessary. Called before pre method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.base.SUL.CacheSUL.step", "modulename": "aalpy.base.SUL", "qualname": "CacheSUL.step", "type": "function", "doc": "<p>Executes an action on the system under learning, adds it to the cache and returns its result.</p>\n\n<p>Args:</p>\n\n<p>letter: Single input that is executed on the SUL.</p>\n\n<p>Returns:</p>\n\n<p>Output received after executing the input.</p>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs", "modulename": "aalpy.learning_algs", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.deterministic", "modulename": "aalpy.learning_algs.deterministic", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.deterministic.CounterExampleProcessing", "modulename": "aalpy.learning_algs.deterministic.CounterExampleProcessing", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.deterministic.CounterExampleProcessing.longest_prefix_cex_processing", "modulename": "aalpy.learning_algs.deterministic.CounterExampleProcessing", "qualname": "longest_prefix_cex_processing", "type": "function", "doc": "<p>Suffix processing strategy found in Shahbaz-Groz paper 'Inferring Mealy Machines'.\nIt splits the counterexample into prefix and suffix. The prefix is the longest element of the S union S.A that\nmatches the beginning of the counterexample. By removing such prefixes from counterexample, no consistency check\nis needed.</p>\n\n<p>Args:</p>\n\n<pre><code>s_union_s_dot_a: list of all prefixes found in observation table sorted from shortest to longest\ncex: counterexample\nclosedness: either 'suffix' or 'prefix'. (Default value = 'suffix')\ns_union_s_dot_a: list:\ncex: tuple: counterexample\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>suffixes to add to the E set\n</code></pre>\n", "signature": "(s_union_s_dot_a: list, cex: tuple, closedness='suffix')", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.deterministic.CounterExampleProcessing.rs_cex_processing", "modulename": "aalpy.learning_algs.deterministic.CounterExampleProcessing", "qualname": "rs_cex_processing", "type": "function", "doc": "<p>Riverst-Schapire counter example processing.</p>\n\n<p>Args:</p>\n\n<pre><code>sul: system under learning\ncex: found counterexample\nhypothesis: hypothesis on which counterexample was found\nsuffix_closedness: If true all suffixes will be added, else just one (Default value = True)\nclosedness: either 'suffix' or 'prefix'. (Default value = 'suffix')\nsul: SUL: system under learning\ncex: tuple: counterexample\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>suffixes to be added to the E set\n</code></pre>\n", "signature": "(\n    sul: aalpy.base.SUL.SUL,\n    cex: tuple,\n    hypothesis,\n    suffix_closedness=True,\n    closedness='suffix'\n)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.deterministic.LStar", "modulename": "aalpy.learning_algs.deterministic.LStar", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.deterministic.LStar.run_Lstar", "modulename": "aalpy.learning_algs.deterministic.LStar", "qualname": "run_Lstar", "type": "function", "doc": "<p>Executes L* algorithm with Riverst-Schapire counter example processing.</p>\n\n<p>Args:</p>\n\n<pre><code>alphabet: input alphabet\n\nsul: system under learning\n\neq_oracle: equivalence oracle\n\nautomaton_type: type of automaton to be learned. Either 'dfa', 'mealy' or 'moore'.\n\nclosing_strategy: closing strategy used in the close method. Either 'longest_first', 'shortest_first' or\n    'single' (Default value = 'longest_first')\n\ncex_processing: Counterexample processing strategy. Either None, 'rs' (Riverst-Schapire) or 'longest_prefix'.\n    (Default value = 'rs')\n\nsuffix_closedness: if True E set will be suffix closed, (Default value = True)\n\nclosedness_type: either 'suffix' or 'prefix'. If suffix, E set will be suffix closed, prefix closed otherwise\n\nmeaning that all prefixes of the suffix will be added. If false, just a single suffix will be added.\n    (Default value = 'suffix')\n\nmax_learning_rounds: number of learning rounds after which learning will terminate (Default value = None)\n\ncache_and_non_det_check: Use caching and non-determinism checks (Default value = True)\n\nreturn_data: if True, a map containing all information(runtime/#queries/#steps) will be returned\n    (Default value = False)\n\nprint_level: 0 - None, 1 - just results, 2 - current round and hypothesis size, 3 - educational/debug\n    (Default value = 2)\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>automaton of type automaton_type (dict containing all information about learning if 'return_data' is True)\n</code></pre>\n", "signature": "(\n    alphabet: list,\n    sul: aalpy.base.SUL.SUL,\n    eq_oracle: aalpy.base.Oracle.Oracle,\n    automaton_type,\n    closing_strategy='longest_first',\n    cex_processing='rs',\n    suffix_closedness=True,\n    closedness_type='suffix',\n    max_learning_rounds=None,\n    cache_and_non_det_check=True,\n    return_data=False,\n    print_level=2\n)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.deterministic.ObservationTable", "modulename": "aalpy.learning_algs.deterministic.ObservationTable", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.deterministic.ObservationTable.ObservationTable", "modulename": "aalpy.learning_algs.deterministic.ObservationTable", "qualname": "ObservationTable", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.deterministic.ObservationTable.ObservationTable.__init__", "modulename": "aalpy.learning_algs.deterministic.ObservationTable", "qualname": "ObservationTable.__init__", "type": "function", "doc": "<p>Constructor of the observation table. Initial queries are asked in the constructor.</p>\n\n<p>Args:</p>\n\n<pre><code>alphabet: input alphabet\nsul: system under learning\nautomaton_type: automaton type, one of ['dfa', 'mealy', 'moore']\n</code></pre>\n\n<p>Returns:</p>\n", "signature": "(\n    self,\n    alphabet: list,\n    sul: aalpy.base.SUL.SUL,\n    automaton_type='mealy'\n)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.deterministic.ObservationTable.ObservationTable.get_rows_to_close", "modulename": "aalpy.learning_algs.deterministic.ObservationTable", "qualname": "ObservationTable.get_rows_to_close", "type": "function", "doc": "<p>Get rows for that need to be closed. Row selection is done according to closing_strategy.\nThe length of the row is defined by the length of the prefix corresponding to the row in the S set.\nlongest_first -> get all rows that need to be closed and ask membership queries for the longest row first\nshortest_first -> get all rows that need to be closed and ask membership queries for the shortest row first\nsingle -> find and ask membership query for the single row</p>\n\n<p>Args:</p>\n\n<pre><code>closing_strategy: one of ['shortest_first', 'longest_first', 'single'] (Default value = 'longest_first')\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>list if non-closed exist, None otherwise: rows that will be moved to S set and closed\n</code></pre>\n", "signature": "(self, closing_strategy='longest_first')", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.deterministic.ObservationTable.ObservationTable.get_causes_of_inconsistency", "modulename": "aalpy.learning_algs.deterministic.ObservationTable", "qualname": "ObservationTable.get_causes_of_inconsistency", "type": "function", "doc": "<p>If the two rows in the S set are the same, but their one letter extensions are not, this method founds\nthe cause of inconsistency and returns it.\n:return:</p>\n\n<p>Returns:</p>\n\n<pre><code>a+e values that are the causes of inconsistency\n</code></pre>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.deterministic.ObservationTable.ObservationTable.s_dot_a", "modulename": "aalpy.learning_algs.deterministic.ObservationTable", "qualname": "ObservationTable.s_dot_a", "type": "function", "doc": "<p>Helper generator function that returns extended S, or S.A set.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.deterministic.ObservationTable.ObservationTable.update_obs_table", "modulename": "aalpy.learning_algs.deterministic.ObservationTable", "qualname": "ObservationTable.update_obs_table", "type": "function", "doc": "<p>Perform the membership queries.</p>\n\n<p>Args:</p>\n\n<pre><code>s_set: Prefixes of S set on which to preform membership queries. If None, then whole S set will be used.\n\ne_set: Suffixes of E set on which to perform membership queries. If None, then whole E set will be used.\n</code></pre>\n\n<p>Returns:</p>\n", "signature": "(self, s_set: list = None, e_set: list = None)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.deterministic.ObservationTable.ObservationTable.gen_hypothesis", "modulename": "aalpy.learning_algs.deterministic.ObservationTable", "qualname": "ObservationTable.gen_hypothesis", "type": "function", "doc": "<p>Generate automaton based on the values found in the observation table.\n:return:</p>\n\n<p>Args:</p>\n\n<pre><code>check_for_duplicate_rows:  (Default value = False)\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Automaton of type `automaton_type`\n</code></pre>\n", "signature": "(\n    self,\n    check_for_duplicate_rows=False\n) -> aalpy.base.Automaton.Automaton", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.deterministic.ObservationTable.ObservationTable.shrink", "modulename": "aalpy.learning_algs.deterministic.ObservationTable", "qualname": "ObservationTable.shrink", "type": "function", "doc": "<p>WIP</p>\n", "signature": "(self, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic", "modulename": "aalpy.learning_algs.non_deterministic", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmLstar", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmLstar", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmLstar.run_abstracted_ONFSM_Lstar", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmLstar", "qualname": "run_abstracted_ONFSM_Lstar", "type": "function", "doc": "<p>Based on ''Learning Abstracted Non-deterministic Finite State Machines'' from Pferscher and Aichernig.\nThe algorithm learns an abstracted onfsm of a non-deterministic system. For the additional abstraction,\nequivalence classes for outputs are used.\nLearning ONFSM relies on all-weather assumption. If this assumption is not satisfied by sampling,\nlearning might not converge to the minimal model and runtime could increase substantially.\nNote that this is the inherent flaw of the all-weather assumption. (All outputs will be seen)\nAALpy v.2.0 will try to solve that problem with a novel approach.</p>\n\n<p>Args:</p>\n\n<pre><code>alphabet: input alphabet\n\nsul: system under learning\n\neq_oracle: equivalence oracle\n\nabstraction_mapping: dictionary containing mappings from abstracted to concrete values (equivalence classes)\n\nn_sampling: number of times that membership/input queries will be asked for each cell in the observation\n    (Default value = 100)\n\nmax_learning_rounds: if max_learning_rounds is reached, learning will stop (Default value = None)\n\ncustom_oracle: if True, warning about oracle type will be removed and custom oracle can be used\n\nreturn_data: if True, map containing all information like number of queries... will be returned\n    (Default value = False)\n\nprint_level: 0 - None, 1 - just results, 2 - current round and hypothesis size, 3 - educational/debug\n    (Default value = 2)\n</code></pre>\n\n<p>Returns:\n    learned abstracted ONFSM</p>\n", "signature": "(\n    alphabet: list,\n    sul: aalpy.base.SUL.SUL,\n    eq_oracle: aalpy.base.Oracle.Oracle,\n    abstraction_mapping: dict,\n    n_sampling=100,\n    max_learning_rounds=None,\n    custom_oracle=False,\n    return_data=False,\n    print_level=2\n)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable.AbstractedNonDetObservationTable", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "qualname": "AbstractedNonDetObservationTable", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable.AbstractedNonDetObservationTable.__init__", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "qualname": "AbstractedNonDetObservationTable.__init__", "type": "function", "doc": "<p>Construction of the abstracted non-deterministic observation table.</p>\n\n<p>Args:</p>\n\n<pre><code>alphabet: input alphabet\nsul: system under learning\nabstraction_mapping: map that translates outputs to abstracted outputs\nn_sampling: number of samples to be performed for each cell\n</code></pre>\n", "signature": "(\n    self,\n    alphabet: list,\n    sul: aalpy.base.SUL.SUL,\n    abstraction_mapping: dict,\n    n_sampling=100\n)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable.AbstractedNonDetObservationTable.update_obs_table", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "qualname": "AbstractedNonDetObservationTable.update_obs_table", "type": "function", "doc": "<p>Perform the membership queries and abstraction on observation table\nWith  the  all-weather  assumption,  each  output  query  is  tried  a  number  of  times  on  the  system,\nand  the  driver  reports  the  set  of  all  possible  outputs.</p>\n\n<p>Args:</p>\n\n<pre><code>s_set: Prefixes of S set on which to preform membership queries (Default value = None)\ne_set: Suffixes of E set on which to perform membership queries\n</code></pre>\n", "signature": "(self, s_set=None, e_set: list = None)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable.AbstractedNonDetObservationTable.abstract_obs_table", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "qualname": "AbstractedNonDetObservationTable.abstract_obs_table", "type": "function", "doc": "<p>Creation of abstracted observation table. The provided abstraction mapping is used to replace outputs by abstracted outputs.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable.AbstractedNonDetObservationTable.add_to_T", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "qualname": "AbstractedNonDetObservationTable.add_to_T", "type": "function", "doc": "<p>Add values to the cell at T[s][e].</p>\n\n<p>Args:</p>\n\n<pre><code>s: prefix\ne: element of S\nvalue: value to be added to the cell\n</code></pre>\n", "signature": "(self, s, e, value)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable.AbstractedNonDetObservationTable.update_extended_S", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "qualname": "AbstractedNonDetObservationTable.update_extended_S", "type": "function", "doc": "<p>Helper generator function that returns extended S, or S.A set.\nFor all values in the cell, create a new row where inputs is parent input plus element of alphabet, and\noutput is parent output plus value in cell.</p>\n\n<p>Returns:</p>\n\n<pre><code>New rows of extended S set.\n</code></pre>\n", "signature": "(self, row)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable.AbstractedNonDetObservationTable.get_row_to_close", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "qualname": "AbstractedNonDetObservationTable.get_row_to_close", "type": "function", "doc": "<p>Get row for that needs to be closed.</p>\n\n<p>Returns:</p>\n\n<pre><code>row that will be moved to S set and closed\n</code></pre>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable.AbstractedNonDetObservationTable.get_row_to_complete", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "qualname": "AbstractedNonDetObservationTable.get_row_to_complete", "type": "function", "doc": "<p>Get row for that needs to be completed.</p>\n\n<p>Returns:</p>\n\n<pre><code>row that will be added to S.A\n</code></pre>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable.AbstractedNonDetObservationTable.get_row_to_make_consistent", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "qualname": "AbstractedNonDetObservationTable.get_row_to_make_consistent", "type": "function", "doc": "<p>Get row that violates consistency.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable.AbstractedNonDetObservationTable.get_distinctive_input_sequence", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "qualname": "AbstractedNonDetObservationTable.get_distinctive_input_sequence", "type": "function", "doc": "<p>get input sequence that leads to a different output sequence for two given input/output sequences</p>\n\n<p>Args:</p>\n\n<pre><code>first_row: row to be compared\nsecond_row: row to be compared\ninp: appended input to first_row and second_row that leads to different state\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>input sequence that leads to different outputs\n</code></pre>\n", "signature": "(self, first_row, second_row, inp)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable.AbstractedNonDetObservationTable.complete_extended_S", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "qualname": "AbstractedNonDetObservationTable.complete_extended_S", "type": "function", "doc": "<p>Add given row to S.A</p>\n\n<p>Args:</p>\n\n<pre><code>row_prefix: row that should be added to S.A\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>the row that has been extended\n</code></pre>\n", "signature": "(self, row_prefix)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable.AbstractedNonDetObservationTable.update_E", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "qualname": "AbstractedNonDetObservationTable.update_E", "type": "function", "doc": "<p></p>\n", "signature": "(self, seq)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable.AbstractedNonDetObservationTable.row_to_hashable", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "qualname": "AbstractedNonDetObservationTable.row_to_hashable", "type": "function", "doc": "<p>Creates the hashable representation of the row. Frozenset is used as the order of element in each cell does not\nmatter</p>\n\n<p>Args:</p>\n\n<pre><code>row_prefix: prefix of the row in the observation table\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>hashable representation of the row\n</code></pre>\n", "signature": "(self, row_prefix)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable.AbstractedNonDetObservationTable.gen_hypothesis", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "qualname": "AbstractedNonDetObservationTable.gen_hypothesis", "type": "function", "doc": "<p>Generate automaton based on the values found in the abstracted observation table.</p>\n\n<p>Returns:</p>\n\n<pre><code>Current abstracted hypothesis\n</code></pre>\n", "signature": "(self) -> aalpy.automata.Onfsm.Onfsm", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable.AbstractedNonDetObservationTable.extend_S_dot_A", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "qualname": "AbstractedNonDetObservationTable.extend_S_dot_A", "type": "function", "doc": "<p>Extends S.A based on counterexample prefixes.</p>\n\n<p>Args:</p>\n\n<p>cex_prefixes: input/output sequences that are added to S.A</p>\n\n<p>Returns:</p>\n\n<p>input/output sequences that have been added to the S.A</p>\n", "signature": "(self, cex_prefixes: list)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable.AbstractedNonDetObservationTable.get_abstraction", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "qualname": "AbstractedNonDetObservationTable.get_abstraction", "type": "function", "doc": "<p>Get an abstraction for a concrete output. If such abstraction is not defined, return output.</p>\n\n<p>Args:</p>\n\n<pre><code>out: output to be abstracted if possible\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>abstracted output or output itself\n</code></pre>\n", "signature": "(self, out)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable.AbstractedNonDetObservationTable.cex_processing", "modulename": "aalpy.learning_algs.non_deterministic.AbstractedOnfsmObservationTable", "qualname": "AbstractedNonDetObservationTable.cex_processing", "type": "function", "doc": "<p>Add counterexample to the observation table. If the counterexample leads to a state where an output of the same equivalence class already exists, the prefixes of the counterexample are added to S.A. Otherwise, the postfixes of counterexample are added to E. </p>\n\n<p>Args:</p>\n\n<pre><code>cex: counterexample that should be added to the observation table\nhypothesis: onfsm that implements the counterexample\n</code></pre>\n", "signature": "(self, cex: tuple, hypothesis: aalpy.automata.Onfsm.Onfsm)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.OnfsmLstar", "modulename": "aalpy.learning_algs.non_deterministic.OnfsmLstar", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.non_deterministic.OnfsmLstar.run_non_det_Lstar", "modulename": "aalpy.learning_algs.non_deterministic.OnfsmLstar", "qualname": "run_non_det_Lstar", "type": "function", "doc": "<p>Based on ''Learning Finite State Models of Observable Nondeterministic Systems in a Testing Context '' from Fakih\net al. Relies on the all-weather assumption. (By sampling we will obtain all possible non-deterministic outputs.\nLearning ONFSM relies on all-weather assumption. If this assumption is not satisfied by sampling,\nlearning might not converge to the minimal model and runtime could increase substantially.\nNote that this is the inherent flaw of the all-weather assumption. (All outputs will be seen)\nAALpy v.2.0 will try to solve that problem with a novel approach.</p>\n\n<p>Args:</p>\n\n<pre><code>alphabet: input alphabet\n\nsul: system under learning\n\neq_oracle: equivalence oracle\n\nn_sampling: number of times that each cell has to be updated. If this number is to low, all-weather condition\n    will not hold and learning will not converge to the correct model. (Default value = 50)\n\nmax_learning_rounds: if max_learning_rounds is reached, learning will stop (Default value = None)\n\ncustom_oracle: if True, warning about oracle type will be removed and custom oracle can be used\n\nreturn_data: if True, map containing all information like number of queries... will be returned\n    (Default value = False)\n\nprint_level: 0 - None, 1 - just results, 2 - current round and hypothesis size, 3 - educational/debug\n    (Default value = 2)\n</code></pre>\n\n<p>Returns:\n    learned ONFSM</p>\n", "signature": "(\n    alphabet: list,\n    sul: aalpy.base.SUL.SUL,\n    eq_oracle: aalpy.base.Oracle.Oracle,\n    n_sampling=50,\n    max_learning_rounds=None,\n    custom_oracle=False,\n    return_data=False,\n    print_level=2\n)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable", "modulename": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable.NonDetObservationTable", "modulename": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable", "qualname": "NonDetObservationTable", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable.NonDetObservationTable.__init__", "modulename": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable", "qualname": "NonDetObservationTable.__init__", "type": "function", "doc": "<p>Construction of the non-deterministic observation table.</p>\n\n<p>Args:</p>\n\n<pre><code>alphabet: input alphabet\nsul: system under learning\nn_sampling: number of samples to be performed for each cell\n</code></pre>\n", "signature": "(self, alphabet: list, sul: aalpy.base.SUL.SUL, n_sampling=100)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable.NonDetObservationTable.get_row_to_close", "modulename": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable", "qualname": "NonDetObservationTable.get_row_to_close", "type": "function", "doc": "<p>Get row for that need to be closed.</p>\n\n<p>Returns:</p>\n\n<pre><code>row that will be moved to S set and closed\n</code></pre>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable.NonDetObservationTable.update_extended_S", "modulename": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable", "qualname": "NonDetObservationTable.update_extended_S", "type": "function", "doc": "<p>Helper generator function that returns extended S, or S.A set.\nFor all values in the cell, create a new row where inputs is parent input plus element of alphabet, and\noutput is parent output plus value in cell.</p>\n\n<p>Returns:</p>\n\n<pre><code>New rows of extended S set.\n</code></pre>\n", "signature": "(self, row)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable.NonDetObservationTable.update_obs_table", "modulename": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable", "qualname": "NonDetObservationTable.update_obs_table", "type": "function", "doc": "<p>Perform the membership queries.\nWith  the  all-weather  assumption,  each  output  query  is  tried  a  number  of  times  on  the  system,\nand  the  driver  reports  the  set  of  all  possible  outputs.</p>\n\n<p>Args:</p>\n\n<pre><code>s_set: Prefixes of S set on which to preform membership queries (Default value = None)\ne_set: Suffixes of E set on which to perform membership queries\n</code></pre>\n", "signature": "(self, s_set=None, e_set: list = None)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable.NonDetObservationTable.gen_hypothesis", "modulename": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable", "qualname": "NonDetObservationTable.gen_hypothesis", "type": "function", "doc": "<p>Generate automaton based on the values found in the observation table.</p>\n\n<p>Returns:</p>\n\n<pre><code>Current hypothesis\n</code></pre>\n", "signature": "(self) -> aalpy.base.Automaton.Automaton", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable.NonDetObservationTable.row_to_hashable", "modulename": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable", "qualname": "NonDetObservationTable.row_to_hashable", "type": "function", "doc": "<p>Creates the hashable representation of the row. Frozenset is used as the order of element in each cell does not\nmatter</p>\n\n<p>Args:</p>\n\n<pre><code>row_prefix: prefix of the row in the observation table\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>hashable representation of the row\n</code></pre>\n", "signature": "(self, row_prefix)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable.NonDetObservationTable.add_to_T", "modulename": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable", "qualname": "NonDetObservationTable.add_to_T", "type": "function", "doc": "<p>Add values to the cell at T[s][e].</p>\n\n<p>Args:</p>\n\n<pre><code>s: prefix\ne: element of S\nvalue: value to be added to the cell\n</code></pre>\n", "signature": "(self, s, e, value)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable.NonDetObservationTable.cex_processing", "modulename": "aalpy.learning_algs.non_deterministic.OnfsmObservationTable", "qualname": "NonDetObservationTable.cex_processing", "type": "function", "doc": "<p>Suffix processing strategy found in Shahbaz-Groz paper 'Inferring Mealy Machines'.\nIt splits the counterexample into prefix and suffix. Prefix is the longest element of the S union S.A that\nmatches the beginning of the counterexample. By removing such prefix from counterexample, no consistency check\nis needed.</p>\n\n<p>Args:</p>\n\n<pre><code>cex: counterexample (inputs/outputs)\n</code></pre>\n\n<p>Returns:\n    suffixes to add to the E set</p>\n", "signature": "(self, cex: tuple)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.TraceTree", "modulename": "aalpy.learning_algs.non_deterministic.TraceTree", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.non_deterministic.TraceTree.SULWrapper", "modulename": "aalpy.learning_algs.non_deterministic.TraceTree", "qualname": "SULWrapper", "type": "class", "doc": "<p>Wrapper for non-deterministic SUL. After every step, input/output pair is added to the tree containing all traces.</p>\n", "bases": "aalpy.base.SUL.SUL"}, {"fullname": "aalpy.learning_algs.non_deterministic.TraceTree.SULWrapper.__init__", "modulename": "aalpy.learning_algs.non_deterministic.TraceTree", "qualname": "SULWrapper.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, sul: aalpy.base.SUL.SUL)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.TraceTree.SULWrapper.pre", "modulename": "aalpy.learning_algs.non_deterministic.TraceTree", "qualname": "SULWrapper.pre", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.TraceTree.SULWrapper.post", "modulename": "aalpy.learning_algs.non_deterministic.TraceTree", "qualname": "SULWrapper.post", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.TraceTree.SULWrapper.step", "modulename": "aalpy.learning_algs.non_deterministic.TraceTree", "qualname": "SULWrapper.step", "type": "function", "doc": "<p>Args:\n  letter: </p>\n\n<p>Returns:</p>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.TraceTree.Node", "modulename": "aalpy.learning_algs.non_deterministic.TraceTree", "qualname": "Node", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.non_deterministic.TraceTree.Node.__init__", "modulename": "aalpy.learning_algs.non_deterministic.TraceTree", "qualname": "Node.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, output)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.TraceTree.Node.get_child", "modulename": "aalpy.learning_algs.non_deterministic.TraceTree", "qualname": "Node.get_child", "type": "function", "doc": "<p>Args:\n  inp: \n  out: </p>\n\n<p>Returns:</p>\n", "signature": "(self, inp, out)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.TraceTree.TraceTree", "modulename": "aalpy.learning_algs.non_deterministic.TraceTree", "qualname": "TraceTree", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.non_deterministic.TraceTree.TraceTree.__init__", "modulename": "aalpy.learning_algs.non_deterministic.TraceTree", "qualname": "TraceTree.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.TraceTree.TraceTree.reset", "modulename": "aalpy.learning_algs.non_deterministic.TraceTree", "qualname": "TraceTree.reset", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.TraceTree.TraceTree.add_to_tree", "modulename": "aalpy.learning_algs.non_deterministic.TraceTree", "qualname": "TraceTree.add_to_tree", "type": "function", "doc": "<p>Args:\n  inp: \n  out: </p>\n\n<p>Returns:</p>\n", "signature": "(self, inp, out)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.non_deterministic.TraceTree.TraceTree.get_all_outputs", "modulename": "aalpy.learning_algs.non_deterministic.TraceTree", "qualname": "TraceTree.get_all_outputs", "type": "function", "doc": "<p>It should basically do this.\nGet to the node that you reach when following input and outputs.\nThan, from that node on, with input values in e, record ALL possible paths that follow it.\nEdi 2 Konstantin:\n    In case of any questions about this, let me know.</p>\n\n<p>Args:\n  inputs: \n  outputs: \n  e: </p>\n\n<p>Returns:</p>\n", "signature": "(self, inputs, outputs, e)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic", "modulename": "aalpy.learning_algs.stochastic", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.DifferenceChecker", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "DifferenceChecker", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "abc.ABC"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.DifferenceChecker.check_difference", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "DifferenceChecker.check_difference", "type": "function", "doc": "<p></p>\n", "signature": "(self, c1: dict, c2: dict, **kwargs) -> bool", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.DifferenceChecker.difference_value", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "DifferenceChecker.difference_value", "type": "function", "doc": "<p></p>\n", "signature": "(self, c1: dict, c2: dict)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.DifferenceChecker.use_diff_value", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "DifferenceChecker.use_diff_value", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.HoeffdingChecker", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "HoeffdingChecker", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "DifferenceChecker"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.HoeffdingChecker.__init__", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "HoeffdingChecker.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, alpha=0.05)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.HoeffdingChecker.check_difference", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "HoeffdingChecker.check_difference", "type": "function", "doc": "<p></p>\n", "signature": "(self, c1: dict, c2: dict, **kwargs) -> bool", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.compute_epsilon", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "compute_epsilon", "type": "function", "doc": "<p></p>\n", "signature": "(alpha1, n1)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.AdvancedHoeffdingChecker", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "AdvancedHoeffdingChecker", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "DifferenceChecker"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.AdvancedHoeffdingChecker.__init__", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "AdvancedHoeffdingChecker.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, alpha=0.05, use_diff=False)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.AdvancedHoeffdingChecker.check_difference", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "AdvancedHoeffdingChecker.check_difference", "type": "function", "doc": "<p></p>\n", "signature": "(self, c1: dict, c2: dict, **kwargs) -> bool", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.AdvancedHoeffdingChecker.use_diff_value", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "AdvancedHoeffdingChecker.use_diff_value", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.AdvancedHoeffdingChecker.difference_value", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "AdvancedHoeffdingChecker.difference_value", "type": "function", "doc": "<p></p>\n", "signature": "(self, c1_out_freq: dict, c2_out_freq: dict)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.ChiSquareChecker", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "ChiSquareChecker", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "DifferenceChecker"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.ChiSquareChecker.__init__", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "ChiSquareChecker.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, alpha=0.001, use_diff_value=False)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.ChiSquareChecker.check_difference", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "ChiSquareChecker.check_difference", "type": "function", "doc": "<p></p>\n", "signature": "(self, c1_out_freq: dict, c2_out_freq: dict, **kwargs) -> bool", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.ChiSquareChecker.use_diff_value", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "ChiSquareChecker.use_diff_value", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.ChiSquareChecker.difference_value", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "ChiSquareChecker.difference_value", "type": "function", "doc": "<p></p>\n", "signature": "(self, c1_out_freq: dict, c2_out_freq: dict)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.DifferenceChecker.ChiSquareChecker.compute_Q", "modulename": "aalpy.learning_algs.stochastic.DifferenceChecker", "qualname": "ChiSquareChecker.compute_Q", "type": "function", "doc": "<p></p>\n", "signature": "(self, c1_out_freq, c2_out_freq, keys)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable.__init__", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable.__init__", "type": "function", "doc": "<p>Constructor of the observation table. Initial queries are asked in the constructor.</p>\n\n<p>Args:</p>\n\n<p>input_alphabet: input alphabet\n  teacher: stochastic teacher\n  alpha: constant used in Hoeffding bound</p>\n", "signature": "(\n    self,\n    input_alphabet: list,\n    automaton_type,\n    teacher: aalpy.learning_algs.stochastic.StochasticTeacher.StochasticTeacher,\n    compatibility_checker: aalpy.learning_algs.stochastic.DifferenceChecker.DifferenceChecker,\n    alpha=0.05,\n    strategy='normal',\n    cex_processing=None\n)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable.refine_not_completed_cells", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable.refine_not_completed_cells", "type": "function", "doc": "<p>Firstly a prefix-tree acceptor is constructed for all non-completed cells and then that tree is used\nfor online testing/sampling.</p>\n\n<p>Args:</p>\n\n<p>uniform: if true, all cells will be uniformly sampled (Default value = False)\n  n_resample: Number of resamples</p>\n\n<p>Returns:</p>\n\n<pre><code>False if no cells are to be refined, True if refining happened\n</code></pre>\n", "signature": "(self, n_resample, uniform=False)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable.update_obs_table_with_freq_obs", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable.update_obs_table_with_freq_obs", "type": "function", "doc": "<p>Updates cells in the observation table with frequency data. If the row in S has no extension yet, it is\ngenerated and its cells populated.</p>\n\n<p>Args:\n  element_of_s: if not None, selected row and its extensions will be updated (Default value = None)</p>\n\n<p>Returns:</p>\n", "signature": "(self, element_of_s=None)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable.get_extended_s", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable.get_extended_s", "type": "function", "doc": "<p>Generator returning all elements of the extended S set.</p>\n\n<p>Args:\n  element_of_s:  (Default value = None)</p>\n\n<p>Returns:</p>\n", "signature": "(self, element_of_s=None)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable.make_closed_and_consistent", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable.make_closed_and_consistent", "type": "function", "doc": "<p>Observation table is updated until it is closed and consistent. Note that due the updated notion of row\nequivalence no sampling is needed.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable.get_row_to_close", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable.get_row_to_close", "type": "function", "doc": "<p>Returns a row that is not closed.</p>\n\n<p>Returns:</p>\n\n<pre><code>row that needs to be closed\n</code></pre>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable.get_consistency_violation", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable.get_consistency_violation", "type": "function", "doc": "<p>Find and return cause of consistency violation. Only computed on the compatibility class representatives.\n:return: element of input + element of output + element of e that lead to the inconsistency</p>\n\n<p>Args:\n  ignore:  (Default value = None)</p>\n\n<p>Returns:</p>\n\n<pre><code>i + o + e that violate consistency\n</code></pre>\n", "signature": "(self, ignore=None)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable.get_representative", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable.get_representative", "type": "function", "doc": "<p>Args:\n  target: row in the observation table</p>\n\n<p>Returns:\n  a representative compatible with the target</p>\n", "signature": "(self, target)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable.trim_columns", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable.trim_columns", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable.trim", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable.trim", "type": "function", "doc": "<p>Removes unnecessary rows from the observation table.</p>\n\n<p>Args:\n  hypothesis:</p>\n", "signature": "(self, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable.stop", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable.stop", "type": "function", "doc": "<p>Decide if learning should terminate.</p>\n\n<p>Args:</p>\n\n<p>learning_round: current learning round\n  chaos_cex_present: is chaos counterexample present in the hypothesis\n  min_rounds: minimum number of learning rounds (Default value = 5)\n  max_rounds: maximum number of learning rounds (Default value = None)\n  target_unambiguity: percentage of rows with unambiguous representatives (Default value = 0.99)\n  print_unambiguity: if true, current unambiguity rate will be printed (Default value = False)</p>\n\n<p>Returns:</p>\n\n<p>True if stopping condition satisfied, false otherwise</p>\n", "signature": "(\n    self,\n    learning_round,\n    chaos_cex_present,\n    min_rounds=10,\n    max_rounds=None,\n    target_unambiguity=0.99,\n    print_unambiguity=False\n)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable.get_unamb_percentage", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable.get_unamb_percentage", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable.cell_diff", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable.cell_diff", "type": "function", "doc": "<p>Checks if 2 cells are considered different.</p>\n\n<p>Args:</p>\n\n<p>s1: prefix of row s1\n  s2: prefix of row s2\n  e: element of E</p>\n\n<p>Returns:</p>\n\n<p>True if cells are different, false otherwise</p>\n", "signature": "(self, s1, s2, e)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable.are_rows_compatible", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable.are_rows_compatible", "type": "function", "doc": "<p>Check if the rows are compatible.\nRows are compatible if all cells are compatible(not different) and their prefixes\nend in the same output element.</p>\n\n<p>Args:\n  s1: prefix of row s1\n  s2: prefix of row s2\n  e_ignore: e not considered for the computation of row compatibility (Default value = None)</p>\n\n<p>Returns:\n  True if rows are compatible, False otherwise</p>\n", "signature": "(self, s1, s2, e_ignore=None)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable.update_compatibility_classes", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable.update_compatibility_classes", "type": "function", "doc": "<p>Updates the compatibility classes and stores their representatives.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable.chaos_counterexample", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable.chaos_counterexample", "type": "function", "doc": "<p>Check whether the chaos state is reachable.</p>\n\n<p>Args:\n  hypothesis: current hypothesis</p>\n\n<p>Returns:\n  True if chaos state is reachable, False otherwise</p>\n", "signature": "(self, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable.add_to_PTA", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable.add_to_PTA", "type": "function", "doc": "<p>Adds a trace to the PTA. PTA is later used for online sampling. The uncertainty value is added to inputs as\nfrequencies, which specify how often a particular input should be sampled.</p>\n\n<p>Args:\n  pta_root: root of the prefix tree acceptor\n  trace: trace to add to the PTA\n  uncertainty_value: uncertainty value (Default value = None)</p>\n\n<p>Returns:</p>\n", "signature": "(self, pta_root, trace, uncertainty_value=None)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable.SamplingBasedObservationTable.generate_hypothesis", "modulename": "aalpy.learning_algs.stochastic.SamplingBasedObservationTable", "qualname": "SamplingBasedObservationTable.generate_hypothesis", "type": "function", "doc": "<p>Generates the hypothesis from the observation table.\n:return: current hypothesis</p>\n\n<p>Args:</p>\n\n<p>Returns:</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticCexProcessing", "modulename": "aalpy.learning_algs.stochastic.StochasticCexProcessing", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticCexProcessing.stochastic_longest_prefix", "modulename": "aalpy.learning_algs.stochastic.StochasticCexProcessing", "qualname": "stochastic_longest_prefix", "type": "function", "doc": "<p>Counterexample processing based on Shabaz-Groz cex processing.</p>\n\n<p>Args:</p>\n\n<pre><code>cex: counterexample\nprefixes: all prefixes in the observation table\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Single suffix.\n</code></pre>\n", "signature": "(cex, prefixes)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticCexProcessing.stochastic_rs", "modulename": "aalpy.learning_algs.stochastic.StochasticCexProcessing", "qualname": "stochastic_rs", "type": "function", "doc": "<p>Riverst-Schapire counter example processing.</p>\n\n<p>Args:</p>\n\n<pre><code>sul: system under learning\ncex: found counterexample\nhypothesis: hypothesis on which counterexample was found\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>suffixes to be added to the E set\n</code></pre>\n", "signature": "(sul: aalpy.base.SUL.SUL, cex: tuple, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticLStar", "modulename": "aalpy.learning_algs.stochastic.StochasticLStar", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticLStar.run_stochastic_Lstar", "modulename": "aalpy.learning_algs.stochastic.StochasticLStar", "qualname": "run_stochastic_Lstar", "type": "function", "doc": "<p>Learning of Markov Decision Processes based on 'L*-Based Learning of Markov Decision Processes'\nand 'Active Model Learning of Stochastic Reactive Systems' by Tappler et al.</p>\n\n<p>Args:</p>\n\n<pre><code>input_alphabet: input alphabet\n\nsul: system under learning\n\neq_oracle: equivalence oracle\n\ntarget_unambiguity: target unambiguity value (default 0.99)\n\nmin_rounds: minimum number of learning rounds (Default value = 10)\n\nmax_rounds: if learning_rounds &gt;= max_rounds, learning will stop (Default value = 200)\n\nautomaton_type: either 'mdp' or 'smm' (Default value = 'mdp')\n\nstrategy: either one of ['classic', 'normal', 'chi2'] or a object implementing DifferenceChecker class,\n    default value is 'normal'. Classic strategy is the one presented\n    in the seed paper, 'normal' is the updated version and chi2 is based on chi squared.\n\ncex_processing: cex processing strategy, None , 'longest_prefix' or 'rs' (rs is experimental)\n\nsamples_cex_strategy: strategy for finding counterexamples in the trace tree. None, 'bfs' or\n    \"random:&lt;#traces to check:int&gt;:&lt;stop probability for single trace in [0,1)&gt;\" eg. random:200:0.2\n\nproperty_based_stopping: A tuple containing (path to the properties file, correct values of each property,\n    allowed error for each property. Recommended one is 0.02 (2%)).\n\ncustom_oracle: if True, warning about oracle type will be removed and custom oracle can be used\n\nreturn_data: if True, map containing all information like number of queries... will be returned\n    (Default value = False)\n\nn_c: cutoff for a cell to be considered complete (Default value = 20), only used with 'classic' strategy\n\nn_resample: resampling size (Default value = 100), only used with 'classic' strategy\n\nprint_level: 0 - None, 1 - just results, 2 - current round and hypothesis size, 3 - educational/debug\n    (Default value = 2)\n</code></pre>\n\n<p>Returns:</p>\n\n<p>learned MDP/SMM</p>\n", "signature": "(\n    input_alphabet,\n    sul: aalpy.base.SUL.SUL,\n    eq_oracle: aalpy.base.Oracle.Oracle,\n    target_unambiguity=0.99,\n    min_rounds=10,\n    max_rounds=200,\n    automaton_type='mdp',\n    strategy='normal',\n    cex_processing=None,\n    samples_cex_strategy=None,\n    custom_oracle=False,\n    return_data=False,\n    property_based_stopping=None,\n    n_c=20,\n    n_resample=100,\n    print_level=2\n)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.StochasticSUL", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "StochasticSUL", "type": "class", "doc": "<p>System Under Learning (SUL) abstract class. Defines the interaction between the learning algorithm and the system\nunder learning. All systems under learning have to implement this class, as it is\npassed to the learning algorithm and the equivalence oracle.</p>\n", "bases": "aalpy.base.SUL.SUL"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.StochasticSUL.__init__", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "StochasticSUL.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, sul, teacher)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.StochasticSUL.pre", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "StochasticSUL.pre", "type": "function", "doc": "<p>Resets the system. Called after post method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.StochasticSUL.post", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "StochasticSUL.post", "type": "function", "doc": "<p>Performs additional cleanup on the system in necessary. Called before pre method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.StochasticSUL.step", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "StochasticSUL.step", "type": "function", "doc": "<p>Executes an action on the system under learning and returns its result.</p>\n\n<p>Args:</p>\n\n<pre><code>letter: Single input that is executed on the SUL.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Output received after executing the input.\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.Node", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "Node", "type": "class", "doc": "<p>Node of the cache/multiset of all traces.</p>\n"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.Node.__init__", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "Node.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, output)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.Node.get_child", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "Node.get_child", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>inp: input\nout: output\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Child with output that equals to `out` reached when performing `inp`. If such child does not exist,\nreturn None.\n</code></pre>\n", "signature": "(self, inp, out)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.Node.get_frequency_sum", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "Node.get_frequency_sum", "type": "function", "doc": "<p>Returns:</p>\n\n<pre><code>number of times input was observed in current state\n</code></pre>\n", "signature": "(self, input_letter)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.Node.get_output_frequencies", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "Node.get_output_frequencies", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>input_letter: input\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>observed outputs and their frequencies for given `input_letter` in the current state\n</code></pre>\n", "signature": "(self, input_letter)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.StochasticTeacher", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "StochasticTeacher", "type": "class", "doc": "<p>The sampling-based teacher maintains a multiset of traces S for the estimation of output distributions.\nWhenever new traces are sampled in the course of learning, they are added to S.</p>\n"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.StochasticTeacher.__init__", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "StochasticTeacher.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    sul: aalpy.base.SUL.SUL,\n    n_c,\n    eq_oracle,\n    automaton_type,\n    compatibility_checker: aalpy.learning_algs.stochastic.DifferenceChecker.DifferenceChecker,\n    samples_cex_strategy=None\n)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.StochasticTeacher.back_to_root", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "StochasticTeacher.back_to_root", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.StochasticTeacher.add", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "StochasticTeacher.add", "type": "function", "doc": "<p>Adds a input/output to the tree.</p>\n\n<p>Args:</p>\n\n<pre><code>inp: input\nout: output\n</code></pre>\n", "signature": "(self, inp, out)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.StochasticTeacher.frequency_query", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "StochasticTeacher.frequency_query", "type": "function", "doc": "<p>Output frequencies observed after trace s + e.</p>\n\n<p>Args:</p>\n\n<pre><code>s: sequence from S set\ne: sequence from E set\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>sum of output frequencies\n</code></pre>\n", "signature": "(self, s: tuple, e: tuple)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.StochasticTeacher.complete_query", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "StochasticTeacher.complete_query", "type": "function", "doc": "<p>Given a test sequences returns true if sufficient information is available to estimate an output distribution\nfrom frequency queries; returns false otherwise.</p>\n\n<p>Args:</p>\n\n<pre><code>s: sequence from S set\ne: sequence from E set\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>True if cell is completed, false otherwise\n</code></pre>\n", "signature": "(self, s: tuple, e: tuple)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.StochasticTeacher.tree_query", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "StochasticTeacher.tree_query", "type": "function", "doc": "<p>Execute a refine query based on input/output trace. If at some point real outputs differ from expected\noutputs, trace to that point is added to the tree, otherwise whole trace is executed.</p>\n\n<p>Args:</p>\n\n<pre><code>pta_root: root of the PTA\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>number of steps taken\n</code></pre>\n", "signature": "(self, pta_root)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.StochasticTeacher.single_dfs_for_cex", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "StochasticTeacher.single_dfs_for_cex", "type": "function", "doc": "<p></p>\n", "signature": "(self, stop_prob, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.StochasticTeacher.dfs_for_cex_in_tree", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "StochasticTeacher.dfs_for_cex_in_tree", "type": "function", "doc": "<p></p>\n", "signature": "(self, hypothesis, nr_traces, stop_prob)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.StochasticTeacher.bfs_for_cex_in_tree", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "StochasticTeacher.bfs_for_cex_in_tree", "type": "function", "doc": "<p></p>\n", "signature": "(self, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic.StochasticTeacher.StochasticTeacher.equivalence_query", "modulename": "aalpy.learning_algs.stochastic.StochasticTeacher", "qualname": "StochasticTeacher.equivalence_query", "type": "function", "doc": "<p>Finds and returns a counterexample</p>\n\n<p>Args:</p>\n\n<pre><code>hypothesis: current hypothesis\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>counterexample\n</code></pre>\n", "signature": "(self, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive", "modulename": "aalpy.learning_algs.stochastic_passive", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic_passive.ActiveAleriga", "modulename": "aalpy.learning_algs.stochastic_passive.ActiveAleriga", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic_passive.ActiveAleriga.Sampler", "modulename": "aalpy.learning_algs.stochastic_passive.ActiveAleriga", "qualname": "Sampler", "type": "class", "doc": "<p>Abstract class whose implementations are used to provide samples for active passive learning.</p>\n", "bases": "abc.ABC"}, {"fullname": "aalpy.learning_algs.stochastic_passive.ActiveAleriga.Sampler.sample", "modulename": "aalpy.learning_algs.stochastic_passive.ActiveAleriga", "qualname": "Sampler.sample", "type": "function", "doc": "<p>Abstract method implementing sampling strategy.</p>\n\n<p>Args:</p>\n\n<pre><code>sul: system under learning\nmodel: current learned model\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Data to be added to the data set for the passive learnign.\n</code></pre>\n", "signature": "(self, sul, model)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive.ActiveAleriga.RandomWordSampler", "modulename": "aalpy.learning_algs.stochastic_passive.ActiveAleriga", "qualname": "RandomWordSampler", "type": "class", "doc": "<p>Abstract class whose implementations are used to provide samples for active passive learning.</p>\n", "bases": "Sampler"}, {"fullname": "aalpy.learning_algs.stochastic_passive.ActiveAleriga.RandomWordSampler.__init__", "modulename": "aalpy.learning_algs.stochastic_passive.ActiveAleriga", "qualname": "RandomWordSampler.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, num_walks, min_walk_len, max_walk_len)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive.ActiveAleriga.RandomWordSampler.sample", "modulename": "aalpy.learning_algs.stochastic_passive.ActiveAleriga", "qualname": "RandomWordSampler.sample", "type": "function", "doc": "<p>Abstract method implementing sampling strategy.</p>\n\n<p>Args:</p>\n\n<pre><code>sul: system under learning\nmodel: current learned model\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Data to be added to the data set for the passive learnign.\n</code></pre>\n", "signature": "(self, sul, model)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive.ActiveAleriga.run_active_Alergia", "modulename": "aalpy.learning_algs.stochastic_passive.ActiveAleriga", "qualname": "run_active_Alergia", "type": "function", "doc": "<p>Active version of IOAlergia algorithm. Based on intermediate hypothesis sampling on the system is performed.\nSampled data is added to the learning data and more accurate model is learned.\nProposed in \"Aichernig and Tappler, Probabilistic Black-Box Reachability Checking\"</p>\n\n<p>Args:</p>\n\n<pre><code>data: initial learning data, in form [[O, (I,O), (I,O)...] ,...] where O is outputs and I input.\nsul: system under learning which is basis for sampling\nsampler: instance of Sampler class\nn_iter: number of iterations of active learning\neps: epsilon value if the default checker is used. Look in run_Alergia for description\ncompatibility_checker: passed to run_Alergia, check there for description\nprint_info: print current learning iteration\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>learned MDP\n</code></pre>\n", "signature": "(\n    data,\n    sul,\n    sampler,\n    n_iter,\n    eps=0.005,\n    compatibility_checker=None,\n    print_info=True\n)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive.Alergia", "modulename": "aalpy.learning_algs.stochastic_passive.Alergia", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic_passive.Alergia.Alergia", "modulename": "aalpy.learning_algs.stochastic_passive.Alergia", "qualname": "Alergia", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic_passive.Alergia.Alergia.__init__", "modulename": "aalpy.learning_algs.stochastic_passive.Alergia", "qualname": "Alergia.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    data,\n    automaton_type,\n    eps=0.005,\n    compatibility_checker=None,\n    print_info=False\n)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive.Alergia.Alergia.compatibility_test", "modulename": "aalpy.learning_algs.stochastic_passive.Alergia", "qualname": "Alergia.compatibility_test", "type": "function", "doc": "<p></p>\n", "signature": "(self, a, b)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive.Alergia.Alergia.merge", "modulename": "aalpy.learning_algs.stochastic_passive.Alergia", "qualname": "Alergia.merge", "type": "function", "doc": "<p></p>\n", "signature": "(self, q_r, q_b)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive.Alergia.Alergia.fold", "modulename": "aalpy.learning_algs.stochastic_passive.Alergia", "qualname": "Alergia.fold", "type": "function", "doc": "<p></p>\n", "signature": "(self, q_r, q_b)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive.Alergia.Alergia.run", "modulename": "aalpy.learning_algs.stochastic_passive.Alergia", "qualname": "Alergia.run", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive.Alergia.Alergia.normalize", "modulename": "aalpy.learning_algs.stochastic_passive.Alergia", "qualname": "Alergia.normalize", "type": "function", "doc": "<p></p>\n", "signature": "(self, red)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive.Alergia.Alergia.get_blue_node", "modulename": "aalpy.learning_algs.stochastic_passive.Alergia", "qualname": "Alergia.get_blue_node", "type": "function", "doc": "<p></p>\n", "signature": "(self, red_node)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive.Alergia.Alergia.to_automaton", "modulename": "aalpy.learning_algs.stochastic_passive.Alergia", "qualname": "Alergia.to_automaton", "type": "function", "doc": "<p></p>\n", "signature": "(self, red)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive.Alergia.run_Alergia", "modulename": "aalpy.learning_algs.stochastic_passive.Alergia", "qualname": "run_Alergia", "type": "function", "doc": "<p>Run Alergia or IOAlergia on provided data.</p>\n\n<p>Args:</p>\n\n<pre><code>data: data either in a form [[I,I,I],[I,I,I],...] if learning Markov Chains or [[O,(I,O),(I,O)...],\n[O,(I,O_,...],..,] if learning MDPs (I represents input, O output).\nNote that in whole data first symbol of each entry should be the same (Initial output of the MDP/MC).\n\neps: epsilon value if you are using default HoeffdingCompatibility. If it is set to 'auto' it will be computed\nas 10/(all steps in the data)\n\nautomaton_type: either 'mdp' if you wish to learn an MDP, 'mc' if you want to learn Markov Chain, and 'moore'\n                if you want to learn Moore Machine (underlying structure is deterministic)\n\ncompatibility_checker: impl. of class CompatibilityChecker, HoeffdingCompatibility with eps value by default\n\n(note: not interchangeable, depends on data)\nprint_info:\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>mdp or markov chain\n</code></pre>\n", "signature": "(\n    data,\n    automaton_type,\n    eps=0.005,\n    compatibility_checker=None,\n    print_info=False\n)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive.CompatibilityChecker", "modulename": "aalpy.learning_algs.stochastic_passive.CompatibilityChecker", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic_passive.CompatibilityChecker.CompatibilityChecker", "modulename": "aalpy.learning_algs.stochastic_passive.CompatibilityChecker", "qualname": "CompatibilityChecker", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "abc.ABC"}, {"fullname": "aalpy.learning_algs.stochastic_passive.CompatibilityChecker.CompatibilityChecker.check_difference", "modulename": "aalpy.learning_algs.stochastic_passive.CompatibilityChecker", "qualname": "CompatibilityChecker.check_difference", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    a: aalpy.learning_algs.stochastic_passive.FPTA.AlergiaPtaNode,\n    b: aalpy.learning_algs.stochastic_passive.FPTA.AlergiaPtaNode,\n    **kwargs\n) -> bool", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive.CompatibilityChecker.HoeffdingCompatibility", "modulename": "aalpy.learning_algs.stochastic_passive.CompatibilityChecker", "qualname": "HoeffdingCompatibility", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "CompatibilityChecker"}, {"fullname": "aalpy.learning_algs.stochastic_passive.CompatibilityChecker.HoeffdingCompatibility.__init__", "modulename": "aalpy.learning_algs.stochastic_passive.CompatibilityChecker", "qualname": "HoeffdingCompatibility.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, eps)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive.CompatibilityChecker.HoeffdingCompatibility.check_difference", "modulename": "aalpy.learning_algs.stochastic_passive.CompatibilityChecker", "qualname": "HoeffdingCompatibility.check_difference", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    a: aalpy.learning_algs.stochastic_passive.FPTA.AlergiaPtaNode,\n    b: aalpy.learning_algs.stochastic_passive.FPTA.AlergiaPtaNode,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive.FPTA", "modulename": "aalpy.learning_algs.stochastic_passive.FPTA", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic_passive.FPTA.AlergiaPtaNode", "modulename": "aalpy.learning_algs.stochastic_passive.FPTA", "qualname": "AlergiaPtaNode", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic_passive.FPTA.AlergiaPtaNode.__init__", "modulename": "aalpy.learning_algs.stochastic_passive.FPTA", "qualname": "AlergiaPtaNode.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, output)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive.FPTA.AlergiaPtaNode.output", "modulename": "aalpy.learning_algs.stochastic_passive.FPTA", "qualname": "AlergiaPtaNode.output", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic_passive.FPTA.AlergiaPtaNode.input_frequency", "modulename": "aalpy.learning_algs.stochastic_passive.FPTA", "qualname": "AlergiaPtaNode.input_frequency", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic_passive.FPTA.AlergiaPtaNode.children", "modulename": "aalpy.learning_algs.stochastic_passive.FPTA", "qualname": "AlergiaPtaNode.children", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic_passive.FPTA.AlergiaPtaNode.prefix", "modulename": "aalpy.learning_algs.stochastic_passive.FPTA", "qualname": "AlergiaPtaNode.prefix", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic_passive.FPTA.AlergiaPtaNode.state_id", "modulename": "aalpy.learning_algs.stochastic_passive.FPTA", "qualname": "AlergiaPtaNode.state_id", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic_passive.FPTA.AlergiaPtaNode.children_prob", "modulename": "aalpy.learning_algs.stochastic_passive.FPTA", "qualname": "AlergiaPtaNode.children_prob", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic_passive.FPTA.AlergiaPtaNode.succs", "modulename": "aalpy.learning_algs.stochastic_passive.FPTA", "qualname": "AlergiaPtaNode.succs", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.learning_algs.stochastic_passive.FPTA.AlergiaPtaNode.children_keys", "modulename": "aalpy.learning_algs.stochastic_passive.FPTA", "qualname": "AlergiaPtaNode.children_keys", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "aalpy.learning_algs.stochastic_passive.FPTA.create_fpta", "modulename": "aalpy.learning_algs.stochastic_passive.FPTA", "qualname": "create_fpta", "type": "function", "doc": "<p></p>\n", "signature": "(data, automaton_type)", "funcdef": "def"}, {"fullname": "aalpy.oracles", "modulename": "aalpy.oracles", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.oracles.BreadthFirstExplorationEqOracle", "modulename": "aalpy.oracles.BreadthFirstExplorationEqOracle", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.oracles.BreadthFirstExplorationEqOracle.BreadthFirstExplorationEqOracle", "modulename": "aalpy.oracles.BreadthFirstExplorationEqOracle", "qualname": "BreadthFirstExplorationEqOracle", "type": "class", "doc": "<p>Breadth-First Exploration of all possible input combinations up to a certain depth.\nExtremely inefficient equivalence oracle and should only be used for demonstrations.</p>\n", "bases": "aalpy.base.Oracle.Oracle"}, {"fullname": "aalpy.oracles.BreadthFirstExplorationEqOracle.BreadthFirstExplorationEqOracle.__init__", "modulename": "aalpy.oracles.BreadthFirstExplorationEqOracle", "qualname": "BreadthFirstExplorationEqOracle.__init__", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>alphabet: input alphabet\n\nsul: system under learning\n\ndepth: depth of the tree\n</code></pre>\n", "signature": "(self, alphabet, sul: aalpy.base.SUL.SUL, depth=5)", "funcdef": "def"}, {"fullname": "aalpy.oracles.BreadthFirstExplorationEqOracle.BreadthFirstExplorationEqOracle.find_cex", "modulename": "aalpy.oracles.BreadthFirstExplorationEqOracle", "qualname": "BreadthFirstExplorationEqOracle.find_cex", "type": "function", "doc": "<p>Return a counterexample (inputs) that displays different behavior on system under learning and\ncurrent hypothesis.</p>\n\n<p>Args:</p>\n\n<p>hypothesis: current hypothesis</p>\n\n<p>Returns:</p>\n\n<pre><code>tuple or list containing counterexample inputs, None if no counterexample is found\n</code></pre>\n", "signature": "(self, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.oracles.CacheBasedEqOracle", "modulename": "aalpy.oracles.CacheBasedEqOracle", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.oracles.CacheBasedEqOracle.CacheBasedEqOracle", "modulename": "aalpy.oracles.CacheBasedEqOracle", "qualname": "CacheBasedEqOracle", "type": "class", "doc": "<p>Equivalence oracle where test case selection is based on the multiset of all traces observed during learning and\nconformance checking. Firstly all leaves of the tree are gathered and then random leaves are extended with a suffix\nof length (max_tree_depth + 'depth_increase') - len(prefix), where prefix is a path to the leaf.</p>\n", "bases": "aalpy.base.Oracle.Oracle"}, {"fullname": "aalpy.oracles.CacheBasedEqOracle.CacheBasedEqOracle.__init__", "modulename": "aalpy.oracles.CacheBasedEqOracle", "qualname": "CacheBasedEqOracle.__init__", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>alphabet: input alphabet\n\nsul: system under learning\n\nnum_walks: number of random walks to perform\n\ndepth_increase: length of random walk that exceeds the maximum depth of the tree\n\nreset_after_cex: if False, total number of queries will equal num_walks, if True, in each execution of\n    find_cex method at most num_walks will be executed\n</code></pre>\n", "signature": "(\n    self,\n    alphabet: list,\n    sul: aalpy.base.SUL.SUL,\n    num_walks=100,\n    depth_increase=5,\n    reset_after_cex=True\n)", "funcdef": "def"}, {"fullname": "aalpy.oracles.CacheBasedEqOracle.CacheBasedEqOracle.find_cex", "modulename": "aalpy.oracles.CacheBasedEqOracle", "qualname": "CacheBasedEqOracle.find_cex", "type": "function", "doc": "<p>Return a counterexample (inputs) that displays different behavior on system under learning and\ncurrent hypothesis.</p>\n\n<p>Args:</p>\n\n<p>hypothesis: current hypothesis</p>\n\n<p>Returns:</p>\n\n<pre><code>tuple or list containing counterexample inputs, None if no counterexample is found\n</code></pre>\n", "signature": "(self, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.oracles.CacheBasedEqOracle.CacheBasedEqOracle.get_paths", "modulename": "aalpy.oracles.CacheBasedEqOracle", "qualname": "CacheBasedEqOracle.get_paths", "type": "function", "doc": "<p>Args:\n  t: \n  paths:  (Default value = None)\n  current_path:  (Default value = None)</p>\n\n<p>Returns:</p>\n", "signature": "(self, t, paths=None, current_path=None)", "funcdef": "def"}, {"fullname": "aalpy.oracles.PacOracle", "modulename": "aalpy.oracles.PacOracle", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.oracles.PacOracle.PacOracle", "modulename": "aalpy.oracles.PacOracle", "qualname": "PacOracle", "type": "class", "doc": "<p>Probably approximately correct oracle. Number of queries is defined by the following equation:\n1 / self.epsilon * (log(1 / self.delta) + self.round * log(2)), where epsilon is the generalization error and delta\nthe confidence. Thus, returned hypothesis is the epsilon-approximation of the correct hypothesis with the probability\n1 - delta (Mohri, M et al.: Foundations of Machine Learning).\nQueries are of random length in a predefined range.</p>\n", "bases": "aalpy.base.Oracle.Oracle"}, {"fullname": "aalpy.oracles.PacOracle.PacOracle.__init__", "modulename": "aalpy.oracles.PacOracle", "qualname": "PacOracle.__init__", "type": "function", "doc": "<p>Default constructor for all equivalence oracles.</p>\n\n<p>Args:</p>\n\n<pre><code>alphabet: input alphabet\nsul: system under learning\n</code></pre>\n", "signature": "(\n    self,\n    alphabet: list,\n    sul: aalpy.base.SUL.SUL,\n    epsilon=0.01,\n    delta=0.01,\n    min_walk_len=10,\n    max_walk_len=25\n)", "funcdef": "def"}, {"fullname": "aalpy.oracles.PacOracle.PacOracle.find_cex", "modulename": "aalpy.oracles.PacOracle", "qualname": "PacOracle.find_cex", "type": "function", "doc": "<p>Return a counterexample (inputs) that displays different behavior on system under learning and\ncurrent hypothesis.</p>\n\n<p>Args:</p>\n\n<p>hypothesis: current hypothesis</p>\n\n<p>Returns:</p>\n\n<pre><code>tuple or list containing counterexample inputs, None if no counterexample is found\n</code></pre>\n", "signature": "(self, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.oracles.RandomWalkEqOracle", "modulename": "aalpy.oracles.RandomWalkEqOracle", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.oracles.RandomWalkEqOracle.RandomWalkEqOracle", "modulename": "aalpy.oracles.RandomWalkEqOracle", "qualname": "RandomWalkEqOracle", "type": "class", "doc": "<p>Equivalence oracle where queries contain random inputs. After every step, 'reset_prob' determines the probability\nthat the system will reset and a new query asked.</p>\n", "bases": "aalpy.base.Oracle.Oracle"}, {"fullname": "aalpy.oracles.RandomWalkEqOracle.RandomWalkEqOracle.__init__", "modulename": "aalpy.oracles.RandomWalkEqOracle", "qualname": "RandomWalkEqOracle.__init__", "type": "function", "doc": "<p>Args:\n    alphabet: input alphabet</p>\n\n<pre><code>sul: system under learning\n\nnum_steps: number of steps to be preformed\n\nreset_after_cex: if true, num_steps will be preformed after every counter example, else the total number\n    or steps will equal to num_steps\n\nreset_prob: probability that the new query will be asked\n</code></pre>\n", "signature": "(\n    self,\n    alphabet: list,\n    sul: aalpy.base.SUL.SUL,\n    num_steps=5000,\n    reset_after_cex=True,\n    reset_prob=0.09\n)", "funcdef": "def"}, {"fullname": "aalpy.oracles.RandomWalkEqOracle.RandomWalkEqOracle.find_cex", "modulename": "aalpy.oracles.RandomWalkEqOracle", "qualname": "RandomWalkEqOracle.find_cex", "type": "function", "doc": "<p>Return a counterexample (inputs) that displays different behavior on system under learning and\ncurrent hypothesis.</p>\n\n<p>Args:</p>\n\n<p>hypothesis: current hypothesis</p>\n\n<p>Returns:</p>\n\n<pre><code>tuple or list containing counterexample inputs, None if no counterexample is found\n</code></pre>\n", "signature": "(self, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.oracles.RandomWalkEqOracle.RandomWalkEqOracle.reset_counter", "modulename": "aalpy.oracles.RandomWalkEqOracle", "qualname": "RandomWalkEqOracle.reset_counter", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.oracles.RandomWordEqOracle", "modulename": "aalpy.oracles.RandomWordEqOracle", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.oracles.RandomWordEqOracle.RandomWordEqOracle", "modulename": "aalpy.oracles.RandomWordEqOracle", "qualname": "RandomWordEqOracle", "type": "class", "doc": "<p>Equivalence oracle where queries are of random length in a predefined range.</p>\n", "bases": "aalpy.base.Oracle.Oracle"}, {"fullname": "aalpy.oracles.RandomWordEqOracle.RandomWordEqOracle.__init__", "modulename": "aalpy.oracles.RandomWordEqOracle", "qualname": "RandomWordEqOracle.__init__", "type": "function", "doc": "<p>Args:\n    alphabet: input alphabet</p>\n\n<pre><code>sul: system under learning\n\nnum_walks: number of walks to perform during search for cex\n\nmin_walk_len: minimum length of each walk\n\nmax_walk_len: maximum length of each walk\n\nreset_after_cex: if True, num_walks will be preformed after every counter example, else the total number\n    or walks will equal to num_walks\n</code></pre>\n", "signature": "(\n    self,\n    alphabet: list,\n    sul: aalpy.base.SUL.SUL,\n    num_walks=100,\n    min_walk_len=10,\n    max_walk_len=100,\n    reset_after_cex=True\n)", "funcdef": "def"}, {"fullname": "aalpy.oracles.RandomWordEqOracle.RandomWordEqOracle.find_cex", "modulename": "aalpy.oracles.RandomWordEqOracle", "qualname": "RandomWordEqOracle.find_cex", "type": "function", "doc": "<p>Return a counterexample (inputs) that displays different behavior on system under learning and\ncurrent hypothesis.</p>\n\n<p>Args:</p>\n\n<p>hypothesis: current hypothesis</p>\n\n<p>Returns:</p>\n\n<pre><code>tuple or list containing counterexample inputs, None if no counterexample is found\n</code></pre>\n", "signature": "(self, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.oracles.RandomWordEqOracle.RandomWordEqOracle.reset_counter", "modulename": "aalpy.oracles.RandomWordEqOracle", "qualname": "RandomWordEqOracle.reset_counter", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.oracles.StatePrefixEqOracle", "modulename": "aalpy.oracles.StatePrefixEqOracle", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.oracles.StatePrefixEqOracle.StatePrefixEqOracle", "modulename": "aalpy.oracles.StatePrefixEqOracle", "qualname": "StatePrefixEqOracle", "type": "class", "doc": "<p>Equivalence oracle that achieves guided exploration by starting random walks from each state a walk_per_state\ntimes. Starting the random walk ensures that all states are reached at least walk_per_state times and that their\nsurrounding is randomly explored. Note that each state serves as a root of random exploration of maximum length\nrand_walk_len exactly walk_per_state times during learning. Therefore excessive testing of initial states is\navoided.</p>\n", "bases": "aalpy.base.Oracle.Oracle"}, {"fullname": "aalpy.oracles.StatePrefixEqOracle.StatePrefixEqOracle.__init__", "modulename": "aalpy.oracles.StatePrefixEqOracle", "qualname": "StatePrefixEqOracle.__init__", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>alphabet: input alphabet\n\nsul: system under learning\n\nwalks_per_state:individual walks per state of the automaton over the whole learning process\n\nwalk_len:length of random walk\n\ndepth_first:first explore newest states\n</code></pre>\n", "signature": "(\n    self,\n    alphabet: list,\n    sul: aalpy.base.SUL.SUL,\n    walks_per_state=10,\n    walk_len=30,\n    depth_first=False\n)", "funcdef": "def"}, {"fullname": "aalpy.oracles.StatePrefixEqOracle.StatePrefixEqOracle.find_cex", "modulename": "aalpy.oracles.StatePrefixEqOracle", "qualname": "StatePrefixEqOracle.find_cex", "type": "function", "doc": "<p>Return a counterexample (inputs) that displays different behavior on system under learning and\ncurrent hypothesis.</p>\n\n<p>Args:</p>\n\n<p>hypothesis: current hypothesis</p>\n\n<p>Returns:</p>\n\n<pre><code>tuple or list containing counterexample inputs, None if no counterexample is found\n</code></pre>\n", "signature": "(self, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.oracles.TransitionFocusOracle", "modulename": "aalpy.oracles.TransitionFocusOracle", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.oracles.TransitionFocusOracle.TransitionFocusOracle", "modulename": "aalpy.oracles.TransitionFocusOracle", "qualname": "TransitionFocusOracle", "type": "class", "doc": "<p>This equivalence oracle focuses either on the same state transitions or transitions that lead to the different\nstates. This equivalence oracle should be used on grammars like balanced parentheses. In such grammars,\nall interesting behavior occurs on the transitions between states and potential bugs can be found only by\nfocusing on transitions.</p>\n", "bases": "aalpy.base.Oracle.Oracle"}, {"fullname": "aalpy.oracles.TransitionFocusOracle.TransitionFocusOracle.__init__", "modulename": "aalpy.oracles.TransitionFocusOracle", "qualname": "TransitionFocusOracle.__init__", "type": "function", "doc": "<p>Args:\n    alphabet: input alphabet\n    sul: system under learning\n    num_random_walks: number of walks\n    walk_len: length of each walk\n    same_state_prob: probability that the next input will lead to same state transition</p>\n", "signature": "(\n    self,\n    alphabet,\n    sul: aalpy.base.SUL.SUL,\n    num_random_walks=1000,\n    walk_len=20,\n    same_state_prob=0.2\n)", "funcdef": "def"}, {"fullname": "aalpy.oracles.TransitionFocusOracle.TransitionFocusOracle.find_cex", "modulename": "aalpy.oracles.TransitionFocusOracle", "qualname": "TransitionFocusOracle.find_cex", "type": "function", "doc": "<p>Return a counterexample (inputs) that displays different behavior on system under learning and\ncurrent hypothesis.</p>\n\n<p>Args:</p>\n\n<p>hypothesis: current hypothesis</p>\n\n<p>Returns:</p>\n\n<pre><code>tuple or list containing counterexample inputs, None if no counterexample is found\n</code></pre>\n", "signature": "(self, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.oracles.UserInputEqOracle", "modulename": "aalpy.oracles.UserInputEqOracle", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.oracles.UserInputEqOracle.UserInputEqOracle", "modulename": "aalpy.oracles.UserInputEqOracle", "qualname": "UserInputEqOracle", "type": "class", "doc": "<p>Interactive equivalence oracle. For every counterexample, the current hypothesis will be visualized and the user can\nenter the counterexample step by step.\nThe user provides elements of the input alphabet or commands.\nWhen the element of the input alphabet is entered, the step will be performed in the current hypothesis and output\nwill be printed.</p>\n\n<p>Commands offered to the users are:</p>\n\n<pre><code>print alphabet - prints the input alphabet\n\ncurrent inputs - inputs entered so far\n\ncex - returns inputs entered so far as the counterexample\n\nend - no counterexample exists\n\nreset - resets the current state of the hypothesis and clears inputs\n</code></pre>\n", "bases": "aalpy.base.Oracle.Oracle"}, {"fullname": "aalpy.oracles.UserInputEqOracle.UserInputEqOracle.__init__", "modulename": "aalpy.oracles.UserInputEqOracle", "qualname": "UserInputEqOracle.__init__", "type": "function", "doc": "<p>Default constructor for all equivalence oracles.</p>\n\n<p>Args:</p>\n\n<pre><code>alphabet: input alphabet\nsul: system under learning\n</code></pre>\n", "signature": "(self, alphabet: list, sul: aalpy.base.SUL.SUL)", "funcdef": "def"}, {"fullname": "aalpy.oracles.UserInputEqOracle.UserInputEqOracle.find_cex", "modulename": "aalpy.oracles.UserInputEqOracle", "qualname": "UserInputEqOracle.find_cex", "type": "function", "doc": "<p>Return a counterexample (inputs) that displays different behavior on system under learning and\ncurrent hypothesis.</p>\n\n<p>Args:</p>\n\n<p>hypothesis: current hypothesis</p>\n\n<p>Returns:</p>\n\n<pre><code>tuple or list containing counterexample inputs, None if no counterexample is found\n</code></pre>\n", "signature": "(self, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.oracles.WMethodEqOracle", "modulename": "aalpy.oracles.WMethodEqOracle", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.oracles.WMethodEqOracle.WMethodEqOracle", "modulename": "aalpy.oracles.WMethodEqOracle", "qualname": "WMethodEqOracle", "type": "class", "doc": "<p>Equivalence oracle based on characterization set/ W-set. From 'Tsun S. Chow.   Testing software design modeled by\nfinite-state machines'.</p>\n", "bases": "aalpy.base.Oracle.Oracle"}, {"fullname": "aalpy.oracles.WMethodEqOracle.WMethodEqOracle.__init__", "modulename": "aalpy.oracles.WMethodEqOracle", "qualname": "WMethodEqOracle.__init__", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>alphabet: input alphabet\nsul: system under learning\nmax_number_of_states: maximum number of states in the automaton\nshuffle_test_set: if True, test cases will be shuffled\n</code></pre>\n", "signature": "(\n    self,\n    alphabet: list,\n    sul: aalpy.base.SUL.SUL,\n    max_number_of_states,\n    shuffle_test_set=True\n)", "funcdef": "def"}, {"fullname": "aalpy.oracles.WMethodEqOracle.WMethodEqOracle.find_cex", "modulename": "aalpy.oracles.WMethodEqOracle", "qualname": "WMethodEqOracle.find_cex", "type": "function", "doc": "<p>Return a counterexample (inputs) that displays different behavior on system under learning and\ncurrent hypothesis.</p>\n\n<p>Args:</p>\n\n<p>hypothesis: current hypothesis</p>\n\n<p>Returns:</p>\n\n<pre><code>tuple or list containing counterexample inputs, None if no counterexample is found\n</code></pre>\n", "signature": "(self, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.oracles.WMethodEqOracle.RandomWMethodEqOracle", "modulename": "aalpy.oracles.WMethodEqOracle", "qualname": "RandomWMethodEqOracle", "type": "class", "doc": "<p>Randomized version of the W-Method equivalence oracle.\nRandom walks stem from fixed prefix (path to the state). At the end of the random\nwalk an element from the characterization set is added to the test case.</p>\n", "bases": "aalpy.base.Oracle.Oracle"}, {"fullname": "aalpy.oracles.WMethodEqOracle.RandomWMethodEqOracle.__init__", "modulename": "aalpy.oracles.WMethodEqOracle", "qualname": "RandomWMethodEqOracle.__init__", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>alphabet: input alphabet\n\nsul: system under learning\n\nwalks_per_state: number of random walks that should start from each state\n\nwalk_len: length of random walk\n</code></pre>\n", "signature": "(\n    self,\n    alphabet: list,\n    sul: aalpy.base.SUL.SUL,\n    walks_per_state=10,\n    walk_len=20\n)", "funcdef": "def"}, {"fullname": "aalpy.oracles.WMethodEqOracle.RandomWMethodEqOracle.find_cex", "modulename": "aalpy.oracles.WMethodEqOracle", "qualname": "RandomWMethodEqOracle.find_cex", "type": "function", "doc": "<p>Return a counterexample (inputs) that displays different behavior on system under learning and\ncurrent hypothesis.</p>\n\n<p>Args:</p>\n\n<p>hypothesis: current hypothesis</p>\n\n<p>Returns:</p>\n\n<pre><code>tuple or list containing counterexample inputs, None if no counterexample is found\n</code></pre>\n", "signature": "(self, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.oracles.kWayStateCoverageEqOracle", "modulename": "aalpy.oracles.kWayStateCoverageEqOracle", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.oracles.kWayStateCoverageEqOracle.KWayStateCoverageEqOracle", "modulename": "aalpy.oracles.kWayStateCoverageEqOracle", "qualname": "KWayStateCoverageEqOracle", "type": "class", "doc": "<p>A test case will be computed for every k-combination or k-permutation of states with additional\nrandom walk at the end.</p>\n", "bases": "aalpy.base.Oracle.Oracle"}, {"fullname": "aalpy.oracles.kWayStateCoverageEqOracle.KWayStateCoverageEqOracle.__init__", "modulename": "aalpy.oracles.kWayStateCoverageEqOracle", "qualname": "KWayStateCoverageEqOracle.__init__", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>alphabet: input alphabet\n\nsul: system under learning\n\nk: k value used for k-wise combinations/permutations of states\n\nrandom_walk_len: length of random walk performed at the end of each combination/permutation\n\nmethod: either 'combinations' or 'permutations'\n</code></pre>\n", "signature": "(\n    self,\n    alphabet: list,\n    sul: aalpy.base.SUL.SUL,\n    k=2,\n    random_walk_len=100,\n    method='combinations'\n)", "funcdef": "def"}, {"fullname": "aalpy.oracles.kWayStateCoverageEqOracle.KWayStateCoverageEqOracle.find_cex", "modulename": "aalpy.oracles.kWayStateCoverageEqOracle", "qualname": "KWayStateCoverageEqOracle.find_cex", "type": "function", "doc": "<p>Return a counterexample (inputs) that displays different behavior on system under learning and\ncurrent hypothesis.</p>\n\n<p>Args:</p>\n\n<p>hypothesis: current hypothesis</p>\n\n<p>Returns:</p>\n\n<pre><code>tuple or list containing counterexample inputs, None if no counterexample is found\n</code></pre>\n", "signature": "(self, hypothesis)", "funcdef": "def"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.KWayTransition", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "KWayTransition", "type": "class", "doc": "<p>KWayTransition(start_state, end_state, steps)</p>\n", "bases": "builtins.tuple"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.KWayTransition.__init__", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "KWayTransition.__init__", "type": "function", "doc": "<p>Create new instance of KWayTransition(start_state, end_state, steps)</p>\n", "signature": "(_cls, start_state, end_state, steps)", "funcdef": "def"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.KWayTransition.start_state", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "KWayTransition.start_state", "type": "variable", "doc": "<p>Alias for field number 0</p>\n"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.KWayTransition.end_state", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "KWayTransition.end_state", "type": "variable", "doc": "<p>Alias for field number 1</p>\n"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.KWayTransition.steps", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "KWayTransition.steps", "type": "variable", "doc": "<p>Alias for field number 2</p>\n"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.Path", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "Path", "type": "class", "doc": "<p>Path(start_state, end_state, steps, kWayTransitions, transitions_log)</p>\n", "bases": "builtins.tuple"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.Path.__init__", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "Path.__init__", "type": "function", "doc": "<p>Create new instance of Path(start_state, end_state, steps, kWayTransitions, transitions_log)</p>\n", "signature": "(\n    _cls,\n    start_state,\n    end_state,\n    steps,\n    kWayTransitions,\n    transitions_log\n)", "funcdef": "def"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.Path.start_state", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "Path.start_state", "type": "variable", "doc": "<p>Alias for field number 0</p>\n"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.Path.end_state", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "Path.end_state", "type": "variable", "doc": "<p>Alias for field number 1</p>\n"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.Path.steps", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "Path.steps", "type": "variable", "doc": "<p>Alias for field number 2</p>\n"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.Path.kWayTransitions", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "Path.kWayTransitions", "type": "variable", "doc": "<p>Alias for field number 3</p>\n"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.Path.transitions_log", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "Path.transitions_log", "type": "variable", "doc": "<p>Alias for field number 4</p>\n"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.KWayTransitionCoverageEqOracle", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "KWayTransitionCoverageEqOracle", "type": "class", "doc": "<p>This Equivalence oracle selects test cases based on k-way transitions coverage. It does that\nby generating random queries and finding the smallest subset with the highest coverage. In other words, this oracle\nfinds counter examples by running random paths that cover all pairwise / k-way transitions.</p>\n", "bases": "aalpy.base.Oracle.Oracle"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.KWayTransitionCoverageEqOracle.__init__", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "KWayTransitionCoverageEqOracle.__init__", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>alphabet: input alphabet\nsul: system under learning\nk: k value used for K-Way transitions, i.e the number of steps between the start and the end of a transition\nmethod: defines how the queries are generated 'random' or 'prefix'\nnum_generate_paths: number of random queries used to find the optimal subset\nmax_path_len: the maximum step size of a generated path\nmax_number_of_steps: maximum number of steps that will be executed on the SUL (0 = no limit)\noptimize: minimize either the number of  'steps' or 'queries' that are executed\nrandom_walk_len: the number of steps that are added by 'prefix' generated paths\n</code></pre>\n", "signature": "(\n    self,\n    alphabet: list,\n    sul: aalpy.base.SUL.SUL,\n    k: int = 2,\n    method='random',\n    num_generate_paths: int = 20000,\n    max_path_len: int = 50,\n    max_number_of_steps: int = 0,\n    optimize: str = 'steps',\n    random_walk_len=10\n)", "funcdef": "def"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.KWayTransitionCoverageEqOracle.find_cex", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "KWayTransitionCoverageEqOracle.find_cex", "type": "function", "doc": "<p>Return a counterexample (inputs) that displays different behavior on system under learning and\ncurrent hypothesis.</p>\n\n<p>Args:</p>\n\n<p>hypothesis: current hypothesis</p>\n\n<p>Returns:</p>\n\n<pre><code>tuple or list containing counterexample inputs, None if no counterexample is found\n</code></pre>\n", "signature": "(self, hypothesis: aalpy.base.Automaton.Automaton)", "funcdef": "def"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.KWayTransitionCoverageEqOracle.greedy_set_cover", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "KWayTransitionCoverageEqOracle.greedy_set_cover", "type": "function", "doc": "<p></p>\n", "signature": "(self, hypothesis: aalpy.base.Automaton.Automaton, paths: list)", "funcdef": "def"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.KWayTransitionCoverageEqOracle.select_optimal_path", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "KWayTransitionCoverageEqOracle.select_optimal_path", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    covered: set,\n    paths: list\n) -> aalpy.oracles.kWayTransitionCoverageEqOracle.Path", "funcdef": "def"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.KWayTransitionCoverageEqOracle.generate_random_paths", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "KWayTransitionCoverageEqOracle.generate_random_paths", "type": "function", "doc": "<p></p>\n", "signature": "(self, hypothesis: aalpy.base.Automaton.Automaton) -> list", "funcdef": "def"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.KWayTransitionCoverageEqOracle.generate_prefix_steps", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "KWayTransitionCoverageEqOracle.generate_prefix_steps", "type": "function", "doc": "<p></p>\n", "signature": "(self, hypothesis: aalpy.base.Automaton.Automaton) -> tuple", "funcdef": "def"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.KWayTransitionCoverageEqOracle.create_path", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "KWayTransitionCoverageEqOracle.create_path", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    hypothesis: aalpy.base.Automaton.Automaton,\n    steps: tuple\n) -> aalpy.oracles.kWayTransitionCoverageEqOracle.Path", "funcdef": "def"}, {"fullname": "aalpy.oracles.kWayTransitionCoverageEqOracle.KWayTransitionCoverageEqOracle.check_path", "modulename": "aalpy.oracles.kWayTransitionCoverageEqOracle", "qualname": "KWayTransitionCoverageEqOracle.check_path", "type": "function", "doc": "<p></p>\n", "signature": "(self, hypothesis: aalpy.base.Automaton.Automaton, steps: tuple)", "funcdef": "def"}, {"fullname": "aalpy.paths", "modulename": "aalpy.paths", "type": "module", "doc": "<p>File in which necessary paths for model checking are defined.</p>\n\n<p>path_to_prism is the absolute or relative path to the prism executable. Note that it has to include the executable file,\nnot just the folder. Eg. /usr/edi/prism/prism.bat and NOT /usr/edi/prism/</p>\n\n<p>If you learn one of the provided examples path to properties should be relative or\nabsolute path to 'Benchmarking\\prism_eval_props'.</p>\n"}, {"fullname": "aalpy.utils", "modulename": "aalpy.utils", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.utils.AutomatonGenerators", "modulename": "aalpy.utils.AutomatonGenerators", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.utils.AutomatonGenerators.generate_random_mealy_machine", "modulename": "aalpy.utils.AutomatonGenerators", "qualname": "generate_random_mealy_machine", "type": "function", "doc": "<p>Generates a random Mealy machine.</p>\n\n<p>Args:</p>\n\n<pre><code>num_states: number of states\ninput_alphabet: input alphabet\noutput_alphabet: output alphabet\ncompute_prefixes: if true, shortest path to reach each state will be computed (Default value = False)\n</code></pre>\n\n<p>Returns:\n    Mealy machine with num_states states</p>\n", "signature": "(\n    num_states,\n    input_alphabet,\n    output_alphabet,\n    compute_prefixes=False\n) -> aalpy.automata.MealyMachine.MealyMachine", "funcdef": "def"}, {"fullname": "aalpy.utils.AutomatonGenerators.generate_random_moore_machine", "modulename": "aalpy.utils.AutomatonGenerators", "qualname": "generate_random_moore_machine", "type": "function", "doc": "<p>Generates a random Moore machine.</p>\n\n<p>Args:</p>\n\n<pre><code>num_states: number of states\ninput_alphabet: input alphabet\noutput_alphabet: output alphabet\ncompute_prefixes: if true, shortest path to reach each state will be computed (Default value = False)\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Moore machine with num_states states\n</code></pre>\n", "signature": "(\n    num_states,\n    input_alphabet,\n    output_alphabet,\n    compute_prefixes=False\n) -> aalpy.automata.MooreMachine.MooreMachine", "funcdef": "def"}, {"fullname": "aalpy.utils.AutomatonGenerators.generate_random_dfa", "modulename": "aalpy.utils.AutomatonGenerators", "qualname": "generate_random_dfa", "type": "function", "doc": "<p>Generates a random DFA.</p>\n\n<p>Args:</p>\n\n<pre><code>num_states: number of states\nalphabet: input alphabet\nnum_accepting_states: number of accepting states (Default value = 1)\ncompute_prefixes: if true, shortest path to reach each state will be computed (Default value = False)\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>DFA\n</code></pre>\n", "signature": "(\n    num_states,\n    alphabet,\n    num_accepting_states=1,\n    compute_prefixes=False\n) -> aalpy.automata.Dfa.Dfa", "funcdef": "def"}, {"fullname": "aalpy.utils.AutomatonGenerators.generate_random_mdp", "modulename": "aalpy.utils.AutomatonGenerators", "qualname": "generate_random_mdp", "type": "function", "doc": "<p>Generates random MDP.</p>\n\n<p>Args:</p>\n\n<pre><code>num_states: number of states\nlen_input: number of inputs\ncustom_outputs: user predefined outputs\nnum_unique_outputs: number of outputs\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>random MDP\n</code></pre>\n", "signature": "(num_states, len_input, custom_outputs=None, num_unique_outputs=None)", "funcdef": "def"}, {"fullname": "aalpy.utils.AutomatonGenerators.generate_random_ONFSM", "modulename": "aalpy.utils.AutomatonGenerators", "qualname": "generate_random_ONFSM", "type": "function", "doc": "<p>Randomly generate an observable non-deterministic finite-state machine.</p>\n\n<p>Args:</p>\n\n<p>num_states: number of states\n  num_inputs: number of inputs\n  num_outputs: number of outputs\n  multiple_out_prob: probability that state will have multiple outputs (Default value = 0.1)</p>\n\n<p>Returns:</p>\n\n<pre><code>randomly generated ONFSM\n</code></pre>\n", "signature": "(num_states, num_inputs, num_outputs, multiple_out_prob=0.1)", "funcdef": "def"}, {"fullname": "aalpy.utils.AutomatonGenerators.generate_random_markov_chain", "modulename": "aalpy.utils.AutomatonGenerators", "qualname": "generate_random_markov_chain", "type": "function", "doc": "<p></p>\n", "signature": "(num_states)", "funcdef": "def"}, {"fullname": "aalpy.utils.AutomatonGenerators.dfa_from_state_setup", "modulename": "aalpy.utils.AutomatonGenerators", "qualname": "dfa_from_state_setup", "type": "function", "doc": "<p>First state in the state setup is the initial state.\nExample state setup:\nstate_setup = {\n        \"a\": (True, {\"x\": \"b1\", \"y\": \"a\"}),\n        \"b1\": (False, {\"x\": \"b2\", \"y\": \"a\"}),\n        \"b2\": (True, {\"x\": \"b3\", \"y\": \"a\"}),\n        \"b3\": (False, {\"x\": \"b4\", \"y\": \"a\"}),\n        \"b4\": (False, {\"x\": \"c\", \"y\": \"a\"}),\n        \"c\": (True, {\"x\": \"a\", \"y\": \"a\"}),\n    }</p>\n\n<p>Args:</p>\n\n<pre><code>state_setup: map from state_id to tuple(output and transitions_dict)\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>DFA\n</code></pre>\n", "signature": "(state_setup) -> aalpy.automata.Dfa.Dfa", "funcdef": "def"}, {"fullname": "aalpy.utils.AutomatonGenerators.moore_from_state_setup", "modulename": "aalpy.utils.AutomatonGenerators", "qualname": "moore_from_state_setup", "type": "function", "doc": "<p>First state in the state setup is the initial state.\nExample state setup:\nstate_setup = {\n        \"a\": (\"a\", {\"x\": \"b1\", \"y\": \"a\"}),\n        \"b1\": (\"b\", {\"x\": \"b2\", \"y\": \"a\"}),\n        \"b2\": (\"b\", {\"x\": \"b3\", \"y\": \"a\"}),\n        \"b3\": (\"b\", {\"x\": \"b4\", \"y\": \"a\"}),\n        \"b4\": (\"b\", {\"x\": \"c\", \"y\": \"a\"}),\n        \"c\": (\"c\", {\"x\": \"a\", \"y\": \"a\"}),\n    }</p>\n\n<p>Args:</p>\n\n<pre><code>state_setup: map from state_id to tuple(output and transitions_dict)\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Moore machine\n</code></pre>\n", "signature": "(state_setup) -> aalpy.automata.MooreMachine.MooreMachine", "funcdef": "def"}, {"fullname": "aalpy.utils.AutomatonGenerators.mealy_from_state_setup", "modulename": "aalpy.utils.AutomatonGenerators", "qualname": "mealy_from_state_setup", "type": "function", "doc": "<p>First state in the state setup is the initial state.\n    state_setup = {\n        \"a\": {\"x\": (\"o1\", \"b1\"), \"y\": (\"o2\", \"a\")},\n        \"b1\": {\"x\": (\"o3\", \"b2\"), \"y\": (\"o1\", \"a\")},\n        \"b2\": {\"x\": (\"o1\", \"b3\"), \"y\": (\"o2\", \"a\")},\n        \"b3\": {\"x\": (\"o3\", \"b4\"), \"y\": (\"o1\", \"a\")},\n        \"b4\": {\"x\": (\"o1\", \"c\"), \"y\": (\"o4\", \"a\")},\n        \"c\": {\"x\": (\"o3\", \"a\"), \"y\": (\"o5\", \"a\")},\n    }</p>\n\n<p>Args:</p>\n\n<pre><code>state_setup:\n    state_setup should map from state_id to tuple(transitions_dict).\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Mealy Machine\n</code></pre>\n", "signature": "(state_setup) -> aalpy.automata.MealyMachine.MealyMachine", "funcdef": "def"}, {"fullname": "aalpy.utils.BenchmarkSULs", "modulename": "aalpy.utils.BenchmarkSULs", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.utils.BenchmarkSULs.get_Angluin_dfa", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "get_Angluin_dfa", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "aalpy.utils.BenchmarkSULs.get_benchmark_ONFSM", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "get_benchmark_ONFSM", "type": "function", "doc": "<p>Returns ONFSM presented in 'Learning Finite State Models of Observable Nondeterministic Systems in a Testing\nContext'.</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "aalpy.utils.BenchmarkSULs.get_ONFSM", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "get_ONFSM", "type": "function", "doc": "<p>Returns example of an ONFSM.</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "aalpy.utils.BenchmarkSULs.get_faulty_coffee_machine_MDP", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "get_faulty_coffee_machine_MDP", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "aalpy.utils.BenchmarkSULs.get_weird_coffee_machine_MDP", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "get_weird_coffee_machine_MDP", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "aalpy.utils.BenchmarkSULs.get_faulty_coffee_machine_SMM", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "get_faulty_coffee_machine_SMM", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "aalpy.utils.BenchmarkSULs.get_minimal_faulty_coffee_machine_SMM", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "get_minimal_faulty_coffee_machine_SMM", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "aalpy.utils.BenchmarkSULs.get_faulty_mqtt_SMM", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "get_faulty_mqtt_SMM", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "aalpy.utils.BenchmarkSULs.get_small_gridworld", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "get_small_gridworld", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "aalpy.utils.BenchmarkSULs.MockMqttExample", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "MockMqttExample", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aalpy.utils.BenchmarkSULs.MockMqttExample.__init__", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "MockMqttExample.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.utils.BenchmarkSULs.MockMqttExample.subscribe", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "MockMqttExample.subscribe", "type": "function", "doc": "<p></p>\n", "signature": "(self, topic: str)", "funcdef": "def"}, {"fullname": "aalpy.utils.BenchmarkSULs.MockMqttExample.unsubscribe", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "MockMqttExample.unsubscribe", "type": "function", "doc": "<p></p>\n", "signature": "(self, topic)", "funcdef": "def"}, {"fullname": "aalpy.utils.BenchmarkSULs.MockMqttExample.connect", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "MockMqttExample.connect", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.utils.BenchmarkSULs.MockMqttExample.disconnect", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "MockMqttExample.disconnect", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.utils.BenchmarkSULs.MockMqttExample.publish", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "MockMqttExample.publish", "type": "function", "doc": "<p></p>\n", "signature": "(self, topic)", "funcdef": "def"}, {"fullname": "aalpy.utils.BenchmarkSULs.DateValidator", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "DateValidator", "type": "class", "doc": "<p>Class mimicking Date Validator API.\nIt does not account for the leap years.\nThe format of the dates is %d/%m/%Y'</p>\n"}, {"fullname": "aalpy.utils.BenchmarkSULs.DateValidator.__init__", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "DateValidator.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "aalpy.utils.BenchmarkSULs.DateValidator.is_date_accepted", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "DateValidator.is_date_accepted", "type": "function", "doc": "<p></p>\n", "signature": "(self, date_string: str)", "funcdef": "def"}, {"fullname": "aalpy.utils.BenchmarkSULs.get_small_pomdp", "modulename": "aalpy.utils.BenchmarkSULs", "qualname": "get_small_pomdp", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "aalpy.utils.DataHandler", "modulename": "aalpy.utils.DataHandler", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.utils.DataHandler.DataHandler", "modulename": "aalpy.utils.DataHandler", "qualname": "DataHandler", "type": "class", "doc": "<p>Abstract class used for data loading for Alergia algorithm. Usage of class is not needed, but recommended for\nconsistency.</p>\n", "bases": "abc.ABC"}, {"fullname": "aalpy.utils.DataHandler.DataHandler.tokenize_data", "modulename": "aalpy.utils.DataHandler", "qualname": "DataHandler.tokenize_data", "type": "function", "doc": "<p></p>\n", "signature": "(self, path)", "funcdef": "def"}, {"fullname": "aalpy.utils.DataHandler.CharacterTokenizer", "modulename": "aalpy.utils.DataHandler", "qualname": "CharacterTokenizer", "type": "class", "doc": "<p>Used for Markov Chain data parsing.\nProcesses data where each input is a single character.\nEach input sequence is in the separate line.</p>\n", "bases": "DataHandler"}, {"fullname": "aalpy.utils.DataHandler.CharacterTokenizer.__init__", "modulename": "aalpy.utils.DataHandler", "qualname": "CharacterTokenizer.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "aalpy.utils.DataHandler.CharacterTokenizer.tokenize_data", "modulename": "aalpy.utils.DataHandler", "qualname": "CharacterTokenizer.tokenize_data", "type": "function", "doc": "<p></p>\n", "signature": "(self, path)", "funcdef": "def"}, {"fullname": "aalpy.utils.DataHandler.DelimiterTokenizer", "modulename": "aalpy.utils.DataHandler", "qualname": "DelimiterTokenizer", "type": "class", "doc": "<p>Used for Markov Chain data parsing.\nProcesses data where each input is separated by the delimiter.\nEach input sequence is in the separate line.</p>\n", "bases": "DataHandler"}, {"fullname": "aalpy.utils.DataHandler.DelimiterTokenizer.__init__", "modulename": "aalpy.utils.DataHandler", "qualname": "DelimiterTokenizer.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "aalpy.utils.DataHandler.DelimiterTokenizer.tokenize_data", "modulename": "aalpy.utils.DataHandler", "qualname": "DelimiterTokenizer.tokenize_data", "type": "function", "doc": "<p></p>\n", "signature": "(self, path, delimiter=',')", "funcdef": "def"}, {"fullname": "aalpy.utils.DataHandler.IODelimiterTokenizer", "modulename": "aalpy.utils.DataHandler", "qualname": "IODelimiterTokenizer", "type": "class", "doc": "<p>Used for Markov Decision Process data parsing.\nProcesses data where each input/output is separated by the io_delimiter, and i/o pairs are separated\nby word delimiter.\nEach [output, tuple(input,output)*] sequence is in the separate line.</p>\n", "bases": "DataHandler"}, {"fullname": "aalpy.utils.DataHandler.IODelimiterTokenizer.__init__", "modulename": "aalpy.utils.DataHandler", "qualname": "IODelimiterTokenizer.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "aalpy.utils.DataHandler.IODelimiterTokenizer.tokenize_data", "modulename": "aalpy.utils.DataHandler", "qualname": "IODelimiterTokenizer.tokenize_data", "type": "function", "doc": "<p></p>\n", "signature": "(self, path, io_delimiter='/', word_delimiter=',')", "funcdef": "def"}, {"fullname": "aalpy.utils.DataHandler.try_int", "modulename": "aalpy.utils.DataHandler", "qualname": "try_int", "type": "function", "doc": "<p></p>\n", "signature": "(x)", "funcdef": "def"}, {"fullname": "aalpy.utils.FileHandler", "modulename": "aalpy.utils.FileHandler", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.utils.FileHandler.visualize_automaton", "modulename": "aalpy.utils.FileHandler", "qualname": "visualize_automaton", "type": "function", "doc": "<p>Create a graphical representation of the automaton.\nFunction is round in the separate thread in the background.\nIf possible, it will be opened by systems default program.</p>\n\n<p>Args:</p>\n\n<pre><code>automaton: automaton to be visualized\n\npath: file in which visualization will be saved (Default value = \"Model_Visualization\")\n\nfile_type: type of file/visualization. Can be ['png', 'svg', 'pdf'] (Default value = 'pdf')\n\ndisplay_same_state_trans: if True, same state transitions will be displayed (Default value = True)\n</code></pre>\n", "signature": "(\n    automaton,\n    path='LearnedModel',\n    file_type='pdf',\n    display_same_state_trans=True\n)", "funcdef": "def"}, {"fullname": "aalpy.utils.FileHandler.save_automaton_to_file", "modulename": "aalpy.utils.FileHandler", "qualname": "save_automaton_to_file", "type": "function", "doc": "<p>The Standard of the automata strictly follows the syntax found at: https://automata.cs.ru.nl/Syntax/Overview.\nFor non-deterministic and stochastic systems syntax can be found on AALpy's Wiki.</p>\n\n<p>Args:</p>\n\n<pre><code>automaton: automaton to be saved to file\n\npath: file in which automaton will be saved (Default value = \"LearnedModel\")\n\nfile_type: Can be ['dot', 'png', 'svg', 'pdf'] (Default value = 'dot')\n\ndisplay_same_state_trans: True, should not be set to false except from the visualization method\n    (Default value = True)\n\nvisualize: visualize the automaton\n\nround_floats: for stochastic automata, round the floating point numbers to defined number of decimal places\n</code></pre>\n\n<p>Returns:</p>\n", "signature": "(\n    automaton,\n    path='LearnedModel',\n    file_type='dot',\n    display_same_state_trans=True,\n    visualize=False,\n    round_floats=None\n)", "funcdef": "def"}, {"fullname": "aalpy.utils.FileHandler.load_automaton_from_file", "modulename": "aalpy.utils.FileHandler", "qualname": "load_automaton_from_file", "type": "function", "doc": "<p>Loads the automaton from the file.\nStandard of the automatas strictly follows syntax found at: https://automata.cs.ru.nl/Syntax/Overview.\nFor non-deterministic and stochastic systems syntax can be found on AALpy's Wiki.</p>\n\n<p>Args:</p>\n\n<pre><code>path: path to the file\n\nautomaton_type: type of the automaton, if not specified it will be automatically determined according,\n    one of ['dfa', 'mealy', 'moore', 'mdp', 'smm', 'onfsm', 'mc']\n\ncompute_prefixes: it True, shortest path to reach every state will be computed and saved in the prefix of\n    the state. Useful when loading the model to use them as a equivalence oracle. (Default value = False)\n</code></pre>\n\n<p>Returns:\n  automaton</p>\n", "signature": "(path, automaton_type, compute_prefixes=False)", "funcdef": "def"}, {"fullname": "aalpy.utils.FileHandler.visualize_fpta", "modulename": "aalpy.utils.FileHandler", "qualname": "visualize_fpta", "type": "function", "doc": "<p></p>\n", "signature": "(red)", "funcdef": "def"}, {"fullname": "aalpy.utils.HelperFunctions", "modulename": "aalpy.utils.HelperFunctions", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.utils.HelperFunctions.extend_set", "modulename": "aalpy.utils.HelperFunctions", "qualname": "extend_set", "type": "function", "doc": "<p>Helper function to extend a list while maintaining set property.\nThey are stored as lists, so with this function set property is maintained.\n:return</p>\n\n<p>Returns:</p>\n\n<pre><code>list of elements that were added to the set\n</code></pre>\n", "signature": "(list_to_extend: list, new_elements: list) -> list", "funcdef": "def"}, {"fullname": "aalpy.utils.HelperFunctions.all_prefixes", "modulename": "aalpy.utils.HelperFunctions", "qualname": "all_prefixes", "type": "function", "doc": "<p>Returns all prefixes of a list.</p>\n\n<p>Args:\n  li: list from which to compute all prefixes</p>\n\n<p>Returns:\n  list of all prefixes</p>\n", "signature": "(li)", "funcdef": "def"}, {"fullname": "aalpy.utils.HelperFunctions.all_suffixes", "modulename": "aalpy.utils.HelperFunctions", "qualname": "all_suffixes", "type": "function", "doc": "<p>Returns all suffixes of a list.</p>\n\n<p>Args:\n  li: list from which to compute all suffixes</p>\n\n<p>Returns:\n  list of all suffixes</p>\n", "signature": "(li)", "funcdef": "def"}, {"fullname": "aalpy.utils.HelperFunctions.profile_function", "modulename": "aalpy.utils.HelperFunctions", "qualname": "profile_function", "type": "function", "doc": "<p>Args:\n  function: callable: \n  sort_key:  (Default value = 'cumtime')</p>\n\n<p>Returns:\n    prints the profiling results</p>\n", "signature": "(function: <built-in function callable>, sort_key='cumtime')", "funcdef": "def"}, {"fullname": "aalpy.utils.HelperFunctions.random_string_generator", "modulename": "aalpy.utils.HelperFunctions", "qualname": "random_string_generator", "type": "function", "doc": "<p>Args:</p>\n\n<p>size:  (Default value = 10)\n  chars:  (Default value = string.ascii_lowercase + string.digits)</p>\n\n<p>Returns:</p>\n\n<pre><code>a random string of length size\n</code></pre>\n", "signature": "(size=10, chars='abcdefghijklmnopqrstuvwxyz0123456789')", "funcdef": "def"}, {"fullname": "aalpy.utils.HelperFunctions.print_learning_info", "modulename": "aalpy.utils.HelperFunctions", "qualname": "print_learning_info", "type": "function", "doc": "<p>Print learning statistics.</p>\n", "signature": "(info: dict)", "funcdef": "def"}, {"fullname": "aalpy.utils.HelperFunctions.print_observation_table", "modulename": "aalpy.utils.HelperFunctions", "qualname": "print_observation_table", "type": "function", "doc": "<p>Prints the whole observation table.</p>\n\n<p>Args:</p>\n\n<pre><code>ot: observation table\ntable_type: 'det', 'non-det', or 'stoc'\n</code></pre>\n", "signature": "(ot, table_type)", "funcdef": "def"}, {"fullname": "aalpy.utils.HelperFunctions.is_suffix_of", "modulename": "aalpy.utils.HelperFunctions", "qualname": "is_suffix_of", "type": "function", "doc": "<p>Args:\n  suffix: target suffix\n  trace: trace in question</p>\n\n<p>Returns:</p>\n\n<pre><code>True if suffix is the suffix of trace.\n</code></pre>\n", "signature": "(suffix, trace) -> bool", "funcdef": "def"}, {"fullname": "aalpy.utils.HelperFunctions.get_cex_prefixes", "modulename": "aalpy.utils.HelperFunctions", "qualname": "get_cex_prefixes", "type": "function", "doc": "<p>Returns all prefixes of the stochastic automaton.</p>\n\n<p>Args:\n    cex: counterexample\n    automaton_type: <code>mdp</code> or <code>smm</code></p>\n\n<p>Returns:</p>\n\n<pre><code>all prefixes of the counterexample based on the `automaton_type`\n</code></pre>\n", "signature": "(cex, automaton_type)", "funcdef": "def"}, {"fullname": "aalpy.utils.HelperFunctions.get_available_oracles_and_err_msg", "modulename": "aalpy.utils.HelperFunctions", "qualname": "get_available_oracles_and_err_msg", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "aalpy.utils.ModelChecking", "modulename": "aalpy.utils.ModelChecking", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aalpy.utils.ModelChecking.get_properties_file", "modulename": "aalpy.utils.ModelChecking", "qualname": "get_properties_file", "type": "function", "doc": "<p></p>\n", "signature": "(exp_name)", "funcdef": "def"}, {"fullname": "aalpy.utils.ModelChecking.get_correct_prop_values", "modulename": "aalpy.utils.ModelChecking", "qualname": "get_correct_prop_values", "type": "function", "doc": "<p></p>\n", "signature": "(exp_name)", "funcdef": "def"}, {"fullname": "aalpy.utils.ModelChecking.mdp_2_prism_format", "modulename": "aalpy.utils.ModelChecking", "qualname": "mdp_2_prism_format", "type": "function", "doc": "<p>Translates MDP to Prims modelling language.</p>\n\n<p>Args:</p>\n\n<pre><code>mdp: markov decision process\n\nname: name of the mdp/experiment\n\noutput_path: output file (Default value = None)\n</code></pre>\n", "signature": "(mdp: aalpy.automata.Mdp.Mdp, name: str, output_path=None)", "funcdef": "def"}, {"fullname": "aalpy.utils.ModelChecking.evaluate_all_properties", "modulename": "aalpy.utils.ModelChecking", "qualname": "evaluate_all_properties", "type": "function", "doc": "<p></p>\n", "signature": "(prism_file_name, properties_file_name)", "funcdef": "def"}, {"fullname": "aalpy.utils.ModelChecking.model_check_properties", "modulename": "aalpy.utils.ModelChecking", "qualname": "model_check_properties", "type": "function", "doc": "<p>Args:\n    model: Markov Decision Process that serves as a basis for model checking.\n    properties: Properties file. It should point to a file under the path_to_properties folder.</p>\n\n<p>Returns:</p>\n\n<pre><code>results of model checking\n</code></pre>\n", "signature": "(model: aalpy.automata.Mdp.Mdp, properties: str)", "funcdef": "def"}, {"fullname": "aalpy.utils.ModelChecking.model_check_experiment", "modulename": "aalpy.utils.ModelChecking", "qualname": "model_check_experiment", "type": "function", "doc": "<p>For our stochastic experiments you can use this function.\nFor example, check learn_stochastic_system_and_do_model_checking in Examples.py</p>\n\n<p>Args:\n    path_to_properties: path to the properties file\n    correct_prop_values: correct values of all properties. In list, where property at index i corresponds to the\n        i-th element of the list.\n    mdp: MDP\n    precision: precision to which round up results</p>\n\n<p>Returns:</p>\n\n<pre><code>results of model checking and absolute differance to the correct results\n</code></pre>\n", "signature": "(path_to_properties, correct_prop_values, mdp, precision=4)", "funcdef": "def"}, {"fullname": "aalpy.utils.ModelChecking.stop_based_on_confidence", "modulename": "aalpy.utils.ModelChecking", "qualname": "stop_based_on_confidence", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>hypothesis: Markov decision process\nproperty_based_stopping: a tuple (path to properties file, list of correct property values, max allowed error)\nprint_level: 2 or 3 if output of model checking is to be printed during learning\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>True if absolute error for all properties is smaller then property_based_stopping[2]\n</code></pre>\n", "signature": "(hypothesis, property_based_stopping, print_level=2)", "funcdef": "def"}, {"fullname": "aalpy.utils.ModelChecking.compare_automata", "modulename": "aalpy.utils.ModelChecking", "qualname": "compare_automata", "type": "function", "doc": "<p>Finds cases of non-conformance between first and second automaton. This is done by performing RandomW equivalence\ncheck. It is possible that number of found counterexamples is smaller than num_cex, as no counterexample will be a\nsuffix of a previously found counterexample.</p>\n\n<p>Args:</p>\n\n<pre><code>aut_1: first automaton\n\naut_2: second automaton\n\nnum_cex: max. number of searches for counterexamples\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>A list of input sequences that revel different behaviour on both automata. Counterexamples are sorted by length.\n</code></pre>\n", "signature": "(\n    aut_1: aalpy.base.Automaton.DeterministicAutomaton,\n    aut_2: aalpy.base.Automaton.DeterministicAutomaton,\n    num_cex=10\n)", "funcdef": "def"}, {"fullname": "aalpy.utils.ModelChecking.TestCaseWrapperSUL", "modulename": "aalpy.utils.ModelChecking", "qualname": "TestCaseWrapperSUL", "type": "class", "doc": "<p>System Under Learning (SUL) abstract class. Defines the interaction between the learning algorithm and the system\nunder learning. All systems under learning have to implement this class, as it is\npassed to the learning algorithm and the equivalence oracle.</p>\n", "bases": "aalpy.base.SUL.SUL"}, {"fullname": "aalpy.utils.ModelChecking.TestCaseWrapperSUL.__init__", "modulename": "aalpy.utils.ModelChecking", "qualname": "TestCaseWrapperSUL.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, sul)", "funcdef": "def"}, {"fullname": "aalpy.utils.ModelChecking.TestCaseWrapperSUL.pre", "modulename": "aalpy.utils.ModelChecking", "qualname": "TestCaseWrapperSUL.pre", "type": "function", "doc": "<p>Resets the system. Called after post method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.utils.ModelChecking.TestCaseWrapperSUL.post", "modulename": "aalpy.utils.ModelChecking", "qualname": "TestCaseWrapperSUL.post", "type": "function", "doc": "<p>Performs additional cleanup on the system in necessary. Called before pre method in the equivalence query.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "aalpy.utils.ModelChecking.TestCaseWrapperSUL.step", "modulename": "aalpy.utils.ModelChecking", "qualname": "TestCaseWrapperSUL.step", "type": "function", "doc": "<p>Executes an action on the system under learning and returns its result.</p>\n\n<p>Args:</p>\n\n<pre><code>letter: Single input that is executed on the SUL.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Output received after executing the input.\n</code></pre>\n", "signature": "(self, letter)", "funcdef": "def"}, {"fullname": "aalpy.utils.ModelChecking.generate_test_cases", "modulename": "aalpy.utils.ModelChecking", "qualname": "generate_test_cases", "type": "function", "doc": "<p>Uses parametrized eq. oracle to construct test cases on the automaton.\nIf automaton are big (200+ states), increase recursion depth if necessary (eg. sys.setrecursionlimit(10000)).</p>\n\n<p>Args:</p>\n\n<pre><code>automaton: deterministic automaton that serves as a basis for test case generation\noracle: oracle that will construct test-cases and record inputs and outputs\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>List of test cases, where each testcase is a tuple containing two elements, and input and an output sequance.\n</code></pre>\n", "signature": "(automaton: aalpy.base.Automaton.DeterministicAutomaton, oracle)", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();